#!/usr/bin/env node
var _this2=this;function _createForOfIteratorHelperLoose(e,n){var t="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(t)return(t=t.call(e)).next.bind(t);if(Array.isArray(e)||(t=_unsupportedIterableToArray(e))||n&&e&&"number"==typeof e.length){t&&(e=t);var r=0;return function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}}}throw TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _unsupportedIterableToArray(e,n){if(e){if("string"==typeof e)return _arrayLikeToArray(e,n);var t=({}).toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?_arrayLikeToArray(e,n):void 0}}function _arrayLikeToArray(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,r=Array(n);t<n;t++)r[t]=e[t];return r}function _newArrowCheck(e,n){if(e!==n)throw TypeError("Cannot instantiate an arrow function")}var _process$argv=process.argv,command=_process$argv[2],args=_process$argv.slice(3),fs=require("fs"),path=require("path"),_require=require("commander"),program=_require.program,GREEN="\x1b[32m",BLUE="\x1b[34m",RESET="\x1b[0m",specialCharRegex=/[0-9!@#$%^&*()_+{}\[\]:;"'<>,.?/~`|\-=\s]/g;function capitalize(e){return e.charAt(0).toUpperCase()+e.slice(1)}function toCamelCase(e){var n=this;return e.replace(/[^a-zA-Z]+/g,"-").replace(/^-+|-+$/g,"").split("-").map((function(e,t){return _newArrowCheck(this,n),0===t?e.toLowerCase():e.charAt(0).toUpperCase()+e.slice(1).toLowerCase()}).bind(this)).join("")}"resource"===command?(program.version("1.0.0").description("Generate route, model, controller, and interface files for a new resource").argument("<name>","Resource name").action((function(e){var n,t=this;_newArrowCheck(this,_this2);var r,a,s=specialCharRegex.test(args[0])?toCamelCase(args[0]):args[0].toLowerCase(),o=args[0]+".model.ts",i=(process.argv.slice(2),(a=function e(n){for(var t,r=fs.readdirSync(n),a=_createForOfIteratorHelperLoose(r);!(t=a()).done;){var s=t.value,i=path.join(n,s);if(fs.statSync(i).isDirectory()){var d=e(i);if(d)return d}else if(s===o)return i}return null}(path.join(process.cwd(),"src")))?{exists:!0,filePath:a}:{exists:!1,filePath:null}),d=capitalize(s),c=path.join(__dirname,"..","src","modules",args[0]),u=path.join(__dirname,"..","src","modules",args[0]),l=path.join(__dirname,"..","src","modules",args[0]),p=path.join(__dirname,"..","src","modules",args[0]),h=path.join(__dirname,"..","src","modules",args[0]),m=path.join(__dirname,"..","src","modules",args[0]),f=(function e(n){return _newArrowCheck(this,t),path.relative(path.join(__dirname,".."),n)}).bind(this);[c,u,p,l].forEach((function(e){_newArrowCheck(this,t),fs.existsSync(e)||fs.mkdirSync(e,{recursive:!0})}).bind(this));var y="\n// Import Router from express\nimport { Router } from 'express';\n\n// Import controller from corresponding module\nimport { \n  create"+d+",\n  createMany"+d+",\n  update"+d+",\n  updateMany"+d+",\n  delete"+d+",\n  deleteMany"+d+",\n  get"+d+"ById,\n  getMany"+d+"\n} from './"+args[0]+".controller';\n\n//Import validation from corresponding module\nimport { validate"+d+"Id } from './"+args[0]+".validation';\n\n// Initialize router\nconst router = Router();\n\n// Define route handlers\n/**\n * @route POST /api/v1/"+args[0]+"/create-"+args[0]+"\n * @description Create a new "+args[0]+"\n * @access Public\n * @param {function} controller - ['create"+d+"']\n */\nrouter.post(\"/create-"+args[0]+'", create'+d+");\n\n/**\n * @route POST /api/v1/"+args[0]+"/create-"+args[0]+"/many\n * @description Create multiple "+args[0]+"\n * @access Public\n * @param {function} controller - ['createMany"+d+"']\n */\nrouter.post(\"/create-"+args[0]+'/many", createMany'+d+");\n\n/**\n * @route PUT /api/v1/"+args[0]+"/update-"+args[0]+"/many\n * @description Update multiple "+args[0]+" information\n * @access Public\n * @param {function} controller - ['updateMany"+d+"']\n */\nrouter.put(\"/update-"+args[0]+'/many", updateMany'+d+");\n\n/**\n * @route PUT /api/v1/"+args[0]+"/update-"+args[0]+"/:id\n * @description Update "+args[0]+" information\n * @param {string} id - The ID of the "+args[0]+" to update\n * @access Public\n * @param {function} controller - ['update"+d+"']\n * @param {function} validation - ['validate"+d+"Id']\n */\nrouter.put(\"/update-"+args[0]+'/:id", validate'+d+"Id, update"+d+");\n\n/**\n * @route DELETE /api/v1/"+args[0]+"/delete-"+args[0]+"/many\n * @description Delete multiple "+args[0]+"\n * @access Public\n * @param {function} controller - ['deleteMany"+d+"']\n */\nrouter.delete(\"/delete-"+args[0]+'/many", deleteMany'+d+");\n\n/**\n * @route DELETE /api/v1/"+args[0]+"/delete-"+args[0]+"/:id\n * @description Delete a "+args[0]+"\n * @param {string} id - The ID of the "+args[0]+" to delete\n * @access Public\n * @param {function} controller - ['delete"+d+"']\n * @param {function} validation - ['validate"+d+"Id']\n */\nrouter.delete(\"/delete-"+args[0]+'/:id", validate'+d+"Id, delete"+d+");\n\n/**\n * @route GET /api/v1/"+args[0]+"/get-"+args[0]+"/many\n * @description Get multiple "+args[0]+"\n * @access Public\n * @param {function} controller - ['getMany"+d+"']\n */\nrouter.get(\"/get-"+args[0]+'/many", getMany'+d+");\n\n/**\n * @route GET /api/v1/"+args[0]+"/get-"+args[0]+"/:id\n * @description Get a "+args[0]+" by ID\n * @param {string} id - The ID of the "+args[0]+" to retrieve\n * @access Public\n * @param {function} controller - ['get"+d+"ById']\n * @param {function} validation - ['validate"+d+"Id']\n */\nrouter.get(\"/get-"+args[0]+'/:id", validate'+d+"Id, get"+d+"ById);\n\n// Export the router\nmodule.exports = router;\n    ",g=path.join(c,args[0]+".route.ts");fs.writeFileSync(g,y.trim());var v="\nimport { Request, Response } from 'express';\nimport { "+s+"Services } from './"+args[0]+".service';\nimport ServerResponse from '../../helpers/responses/custom-response';\nimport catchAsync from '../../utils/catch-async/catch-async';\n\n/**\n * Controller function to handle the creation of a single "+d+".\n *\n * @param {Request} req - The request object containing "+args[0]+" data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const create"+d+" = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to create a new "+args[0]+" and get the result\n  const result = await "+s+"Services.create"+d+"(req.body);\n  // Send a success response with the created resource data\n  ServerResponse(res, true, 201, '"+d+" created successfully', result);\n});\n\n/**\n * Controller function to handle the creation of multiple "+args[0]+".\n *\n * @param {Request} req - The request object containing an array of "+args[0]+" data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const createMany"+d+" = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to create multiple "+s+"s and get the result\n  const result = await "+s+"Services.createMany"+d+"(req.body);\n  // Send a success response with the created resources data\n  ServerResponse(res, true, 201, 'Resources created successfully', result);\n});\n\n/**\n * Controller function to handle the update operation for a single "+args[0]+".\n *\n * @param {Request} req - The request object containing the ID of the "+args[0]+" to update in URL parameters and the updated data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const update"+d+" = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to update the "+args[0]+" by ID and get the result\n  const result = await "+s+"Services.update"+d+"(id, req.body);\n  // Send a success response with the updated resource data\n  ServerResponse(res, true, 200, '"+d+" updated successfully', result);\n});\n\n/**\n * Controller function to handle the update operation for multiple "+args[0]+".\n *\n * @param {Request} req - The request object containing an array of "+args[0]+" data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const updateMany"+d+" = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to update multiple "+args[0]+" and get the result\n  const result = await "+s+"Services.updateMany"+d+"(req.body);\n  // Send a success response with the updated resources data\n  ServerResponse(res, true, 200, 'Resources updated successfully', result);\n});\n\n/**\n * Controller function to handle the deletion of a single "+args[0]+".\n *\n * @param {Request} req - The request object containing the ID of the "+args[0]+" to delete in URL parameters.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const delete"+d+" = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to delete the "+args[0]+" by ID\n  await "+s+"Services.delete"+d+"(id);\n  // Send a success response confirming the deletion\n  ServerResponse(res, true, 200, '"+d+" deleted successfully');\n});\n\n/**\n * Controller function to handle the deletion of multiple "+args[0]+".\n *\n * @param {Request} req - The request object containing an array of IDs of "+args[0]+" to delete in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const deleteMany"+d+" = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to delete multiple "+args[0]+" and get the result\n  await "+s+"Services.deleteMany"+d+"(req.body);\n  // Send a success response confirming the deletions\n  ServerResponse(res, true, 200, 'Resources deleted successfully');\n});\n\n/**\n * Controller function to handle the retrieval of a single "+args[0]+" by ID.\n *\n * @param {Request} req - The request object containing the ID of the "+args[0]+" to retrieve in URL parameters.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const get"+d+"ById = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to get the "+args[0]+" by ID and get the result\n  const result = await "+s+"Services.get"+d+"ById(id);\n  // Send a success response with the retrieved resource data\n  ServerResponse(res, true, 200, '"+d+" retrieved successfully', result);\n});\n\n/**\n * Controller function to handle the retrieval of multiple "+args[0]+".\n *\n * @param {Request} req - The request object containing query parameters for filtering.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const getMany"+d+" = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to get multiple "+args[0]+" based on query parameters and get the result\n  const result = await "+s+"Services.getMany"+d+"(req.query);\n  // Send a success response with the retrieved resources data\n  ServerResponse(res, true, 200, 'Resources retrieved successfully', result);\n});\n    ",b=path.join(u,args[0]+".controller.ts");fs.writeFileSync(b,v.trim());var R="\nimport mongoose, { Document, Schema } from 'mongoose';\n\n// Define an interface representing a "+d+" document\ninterface I"+d+" extends Document {\n  // Define the schema fields with their types\n  // Example fields (replace with actual fields)\n  // fieldName: fieldType;\n}\n\n// Define the "+d+" schema\nconst "+d+"Schema: Schema<I"+d+"> = new Schema({\n  // Define schema fields here\n  // Example fields (replace with actual schema)\n  // fieldName: {\n  //   type: Schema.Types.FieldType,\n  //   required: true,\n  //   trim: true,\n  // },\n});\n\n// Create the "+d+" model\nconst "+d+" = mongoose.model<I"+d+">('"+d+"', "+d+"Schema);\n\n// Export the "+d+" model\nexport default "+d+";\n    ",q=path.join(p,args[0]+".model.ts");i.exists||fs.writeFileSync(q,R.trim());var S="\n/**\n * Type definition for "+d+".\n *\n * This type defines the structure of a single "+s+" object.\n * @interface T"+d+"\n */\nexport interface T"+d+" {\n  // Add fields as needed\n}\n    ",T=path.join(l,args[0]+".interface.ts");fs.writeFileSync(T,S.trim());var $="\nimport { NextFunction, Request, Response } from 'express';\nimport { isMongoId } from 'validator';\nimport { z } from 'zod';\nimport zodErrorHandler from '../../handlers/zod-error-handler';\n\n/**\n * Zod schema for validating "+s+" data.\n */\nconst zod"+d+'Schema = z.object({\n  id: z\n    .string({\n      required_error: "Id is required",\n      invalid_type_error: "Please provide a valid id",\n    })\n    .refine((id: string) => isMongoId(id), {\n      message: "Please provide a valid id",\n    }),\n  ids: z\n    .array(z.string().refine((id: string) => isMongoId(id), {\n      message: "Each ID must be a valid MongoDB ObjectId",\n    }))\n    .min(1, {\n      message: "At least one ID must be provided",\n    }),\n}).strict();\n    \n/**\n * Middleware function to validate '+s+" ID using Zod schema.\n * @param {object} req - The request object.\n * @param {object} res - The response object.\n * @param {function} next - The next middleware function.\n * @returns {void}\n */\nexport const validate"+d+"Id = (req: Request, res: Response, next: NextFunction) => {\n  // Validate request params\n  const { error, success } = zod"+d+"Schema.pick({ id: true }).safeParse({ id: req.params.id });\n\n  // Check if validation was successful\n  if (!success) {\n    // If validation failed, use the Zod error handler to send an error response\n    return zodErrorHandler(req, res, error);\n  }\n\n  // If validation passed, proceed to the next middleware function\n  return next();\n};\n    ",I=path.join(h,args[0]+".validation.ts");fs.writeFileSync(I,$.trim());var E=null==i||null===(n=i.filePath)||void 0===n?void 0:n.substring(i.filePath.indexOf("modules")+7+1),w="\n// Import the model\nimport "+d+"Model from '"+(i.exists?"../"+E.replace(/\\/g,"/").replace(/\.ts$/,""):"./"+args[0]+".model")+"';\n\n/**\n * Service function to create a new "+s+".\n *\n * @param data - The data to create a new "+s+".\n * @returns {Promise<"+d+">} - The created "+s+".\n */\nconst create"+d+" = async (data: object) => {\n  const new"+d+" = new "+d+"Model(data);\n  return await new"+d+".save();\n};\n\n/**\n * Service function to create multiple "+s+".\n *\n * @param data - An array of data to create multiple "+s+".\n * @returns {Promise<"+d+"[]>} - The created "+s+".\n */\nconst createMany"+d+" = async (data: object[]) => {\n  return await "+d+"Model.insertMany(data);\n};\n\n/**\n * Service function to update a single "+s+" by ID.\n *\n * @param id - The ID of the "+s+" to update.\n * @param data - The updated data for the "+s+".\n * @returns {Promise<"+d+">} - The updated "+s+".\n */\nconst update"+d+" = async (id: string, data: object) => {\n  return await "+d+"Model.findByIdAndUpdate(id, data, { new: true });\n};\n\n/**\n * Service function to update multiple "+s+".\n *\n * @param data - An array of data to update multiple "+s+".\n * @returns {Promise<"+d+"[]>} - The updated "+s+".\n */\nconst updateMany"+d+" = async (data: { id: string, updates: object }[]) => {\n  const updatePromises = data.map(({ id, updates }) =>\n    "+d+"Model.findByIdAndUpdate(id, updates, { new: true })\n  );\n  return await Promise.all(updatePromises);\n};\n\n/**\n * Service function to delete a single "+s+" by ID.\n *\n * @param id - The ID of the "+s+" to delete.\n * @returns {Promise<"+d+">} - The deleted "+s+".\n */\nconst delete"+d+" = async (id: string) => {\n  return await "+d+"Model.findByIdAndDelete(id);\n};\n\n/**\n * Service function to delete multiple "+s+".\n *\n * @param ids - An array of IDs of "+s+" to delete.\n * @returns {Promise<"+d+"[]>} - The deleted "+s+".\n */\nconst deleteMany"+d+" = async (ids: string[]) => {\n  return await "+d+"Model.deleteMany({ _id: { $in: ids } });\n};\n\n/**\n * Service function to retrieve a single "+s+" by ID.\n *\n * @param id - The ID of the "+s+" to retrieve.\n * @returns {Promise<"+d+">} - The retrieved "+s+".\n */\nconst get"+d+"ById = async (id: string) => {\n  return await "+d+"Model.findById(id);\n};\n\n/**\n * Service function to retrieve multiple "+s+" based on query parameters.\n *\n * @param query - The query parameters for filtering "+s+".\n * @returns {Promise<"+d+"[]>} - The retrieved "+s+".\n */\nconst getMany"+d+" = async (query: object) => {\n  return await "+d+"Model.find(query);\n};\n\nexport const "+s+"Services = {\n  create"+d+",\n  createMany"+d+",\n  update"+d+",\n  updateMany"+d+",\n  delete"+d+",\n  deleteMany"+d+",\n  get"+d+"ById,\n  getMany"+d+",\n};\n\n    ",j=path.join(m,args[0]+".service.ts");fs.writeFileSync(j,w.trim()),console.log(GREEN+"CREATE "+RESET+f(b)+" "+BLUE+"("+Buffer.byteLength(v,"utf8")+" bytes)"),console.log(GREEN+"CREATE "+RESET+f(T)+" "+BLUE+"("+Buffer.byteLength(S,"utf8")+" bytes)"),i.exists||console.log(GREEN+"CREATE "+RESET+f(q)+" "+BLUE+"("+Buffer.byteLength(R,"utf8")+" bytes)"),console.log(GREEN+"CREATE "+RESET+f(g)+" "+BLUE+"("+Buffer.byteLength(y,"utf8")+" bytes)"),console.log(GREEN+"CREATE "+RESET+f(j)+" "+BLUE+"("+Buffer.byteLength(w,"utf8")+" bytes)"),console.log(GREEN+"CREATE "+RESET+f(I)+" "+BLUE+"("+Buffer.byteLength($,"utf8")+" bytes)")}).bind(this)),program.parse(process.argv)):"nested-resource"===command?(program.version("1.0.0").description("Generate nested route, model, controller, and interface files for a new resource").argument("<path>","Nested path to resource (e.g., folder1/folder2/resourceName)").action((function(e){var n=this;_newArrowCheck(this,_this2);var t,r,a=args[0].split("/"),s=a[a.length-1]+".model.ts",o=(process.argv.slice(2),(r=function e(n){for(var t,r=fs.readdirSync(n),a=_createForOfIteratorHelperLoose(r);!(t=a()).done;){var o=t.value,i=path.join(n,o);if(fs.statSync(i).isDirectory()){var d=e(i);if(d)return d}else if(o===s)return i}return null}(path.join(process.cwd(),"src")))?{exists:!0,filePath:r}:{exists:!1,filePath:null}),i=a.pop(),d=specialCharRegex.test(args[0])?toCamelCase(i):i.toLowerCase(),c=a,u=capitalize(d),l=path.join(__dirname,"..","src"),p=path.join.apply(path,[l,"modules"].concat(c,[i])),h=(function e(t){return _newArrowCheck(this,n),path.relative(path.join(__dirname,".."),t)}).bind(this);fs.existsSync(p)||fs.mkdirSync(p,{recursive:!0});var m="\n// Import Router from express\nimport { Router } from 'express';\n\n// Import controller from corresponding module\nimport { \n  create"+u+",\n  createMany"+u+",\n  update"+u+",\n  updateMany"+u+",\n  delete"+u+",\n  deleteMany"+u+",\n  get"+u+"ById,\n  getMany"+u+"\n} from './"+i+".controller';\n\n//Import validation from corresponding module\nimport { validate"+u+"Id } from './"+i+".validation';\n      \n// Initialize router\nconst router = Router();\n\n// Define route handlers\n/**\n * @route POST /api/v1/"+c.join("/")+"/"+i+"/create-"+i+"\n * @description Create a new "+i+"\n * @access Public\n * @param {function} controller - ['create"+u+"']\n */\nrouter.post(\"/create-"+i+'", create'+u+");\n\n/**\n * @route POST /api/v1/"+c.join("/")+"/"+i+"/create-"+i+"/many\n * @description Create multiple "+i+"\n * @access Public\n * @param {function} controller - ['createMany"+u+"']\n */\nrouter.post(\"/create-"+i+'/many", createMany'+u+");\n\n/**\n * @route PUT /api/v1/"+c.join("/")+"/"+i+"/update-"+i+"/many\n * @description Update multiple "+i+" information\n * @access Public\n * @param {function} controller - ['updateMany"+u+"']\n */\nrouter.put(\"/update-"+i+'/many", updateMany'+u+");\n\n/**\n * @route PUT /api/v1/"+c.join("/")+"/"+i+"/update-"+i+"/:id\n * @description Update "+i+" information\n * @param {string} id - The ID of the "+i+" to update\n * @access Public\n * @param {function} controller - ['update"+u+"']\n * @param {function} validation - ['validate"+u+"Id']\n */\nrouter.put(\"/update-"+i+'/:id", validate'+u+"Id, update"+u+");\n\n/**\n * @route DELETE /api/v1/"+c.join("/")+"/"+i+"/delete-"+i+"/many\n * @description Delete multiple "+i+"\n * @access Public\n * @param {function} controller - ['deleteMany"+u+"']\n */\nrouter.delete(\"/delete-"+i+'/many", deleteMany'+u+");\n\n/**\n * @route DELETE /api/v1/"+c.join("/")+"/"+i+"/delete-"+i+"/:id\n * @description Delete a "+i+"\n * @param {string} id - The ID of the "+i+" to delete\n * @access Public\n * @param {function} controller - ['delete"+u+"']\n * @param {function} validation - ['validate"+u+"Id']\n */\nrouter.delete(\"/delete-"+i+'/:id", validate'+u+"Id, delete"+u+");\n\n/**\n * @route GET /api/v1/"+c.join("/")+"/"+i+"/get-"+i+"/many\n * @description Get multiple "+i+"\n * @access Public\n * @param {function} controller - ['getMany"+u+"']\n */\nrouter.get(\"/get-"+i+'/many", getMany'+u+");\n\n/**\n * @route GET /api/v1/"+c.join("/")+"/"+i+"/get-"+i+"/:id\n * @description Get a "+i+" by ID\n * @param {string} id - The ID of the "+i+" to retrieve\n * @access Public\n * @param {function} controller - ['get"+u+"ById']\n * @param {function} validation - ['validate"+u+"Id']\n */\nrouter.get(\"/get-"+i+'/:id", validate'+u+"Id, get"+u+"ById);\n\n// Export the router\nmodule.exports = router;\n    ",f=path.join(p,i+".route.ts");fs.writeFileSync(f,m.trim());var y="\nimport { Request, Response } from 'express';\nimport { "+d+"Services } from './"+i+".service';\nimport ServerResponse from '"+Array(c.length+2).fill("..").join("/")+"/helpers/responses/custom-response';\nimport catchAsync from '"+Array(c.length+2).fill("..").join("/")+"/utils/catch-async/catch-async';\n\n/**\n * Controller function to handle the creation of a single "+u+".\n *\n * @param {Request} req - The request object containing "+i+" data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const create"+u+" = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to create a new "+i+" and get the result\n  const result = await "+d+"Services.create"+u+"(req.body);\n  // Send a success response with the created resource data\n  ServerResponse(res, true, 201, '"+u+" created successfully', result);\n});\n\n/**\n * Controller function to handle the creation of multiple "+i+".\n *\n * @param {Request} req - The request object containing an array of "+i+" data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const createMany"+u+" = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to create multiple "+i+" and get the result\n  const result = await "+d+"Services.createMany"+u+"(req.body);\n  // Send a success response with the created resources data\n  ServerResponse(res, true, 201, 'Resources created successfully', result);\n});\n\n/**\n * Controller function to handle the update operation for a single "+u+".\n *\n * @param {Request} req - The request object containing the ID of the "+i+" to update in URL parameters and the updated data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const update"+u+" = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to update the "+i+" by ID and get the result\n  const result = await "+d+"Services.update"+u+"(id, req.body);\n  // Send a success response with the updated resource data\n  ServerResponse(res, true, 200, '"+u+" updated successfully', result);\n});\n\n/**\n * Controller function to handle the update operation for multiple "+i+".\n *\n * @param {Request} req - The request object containing an array of "+i+" data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const updateMany"+u+" = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to update multiple "+i+" and get the result\n  const result = await "+d+"Services.updateMany"+u+"(req.body);\n  // Send a success response with the updated resources data\n  ServerResponse(res, true, 200, 'Resources updated successfully', result);\n});\n\n/**\n * Controller function to handle the deletion of a single "+u+".\n *\n * @param {Request} req - The request object containing the ID of the "+i+" to delete in URL parameters.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const delete"+u+" = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to delete the "+i+" by ID\n  await "+d+"Services.delete"+u+"(id);\n  // Send a success response confirming the deletion\n  ServerResponse(res, true, 200, '"+u+" deleted successfully');\n});\n\n/**\n * Controller function to handle the deletion of multiple "+i+".\n *\n * @param {Request} req - The request object containing an array of IDs of "+i+" to delete in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const deleteMany"+u+" = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to delete multiple "+i+" and get the result\n  await "+d+"Services.deleteMany"+u+"(req.body);\n  // Send a success response confirming the deletions\n  ServerResponse(res, true, 200, 'Resources deleted successfully');\n});\n\n/**\n * Controller function to handle the retrieval of a single "+u+" by ID.\n *\n * @param {Request} req - The request object containing the ID of the "+i+" to retrieve in URL parameters.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const get"+u+"ById = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to get the "+i+" by ID and get the result\n  const result = await "+d+"Services.get"+u+"ById(id);\n  // Send a success response with the retrieved resource data\n  ServerResponse(res, true, 200, '"+u+" retrieved successfully', result);\n});\n\n/**\n * Controller function to handle the retrieval of multiple "+i+".\n *\n * @param {Request} req - The request object containing query parameters for filtering.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const getMany"+u+" = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to get multiple "+i+" based on query parameters and get the result\n  const result = await "+d+"Services.getMany"+u+"(req.query);\n  // Send a success response with the retrieved resources data\n  ServerResponse(res, true, 200, 'Resources retrieved successfully', result);\n});\n    ",g=path.join(p,i+".controller.ts");fs.writeFileSync(g,y.trim());var v="\nimport mongoose, { Document, Schema } from 'mongoose';\n\ninterface I"+u+" extends Document {\n  // Define the schema fields with their types\n}\n\nconst "+u+"Schema: Schema<I"+u+"> = new Schema({\n  // Define schema fields here\n});\n\nconst "+u+" = mongoose.model<I"+u+">('"+u+"', "+u+"Schema);\n\nexport default "+u+";\n    ",b=path.join(p,i+".model.ts");o.exists||fs.writeFileSync(b,v.trim());var R="\nexport interface T"+u+" {\n  // Add fields as needed\n}\n    ",q=path.join(p,i+".interface.ts");fs.writeFileSync(q,R.trim());var S="\nimport { NextFunction, Request, Response } from 'express';\nimport { isMongoId } from 'validator';\nimport { z } from 'zod';\nimport zodErrorHandler from '"+Array(c.length+2).fill("..").join("/")+"/handlers/zod-error-handler';\n\n/**\n * Zod schema for validating "+i+" data.\n */\nconst zod"+u+'Schema = z.object({\n  id: z\n    .string({\n      required_error: "Id is required",\n      invalid_type_error: "Please provide a valid id",\n    })\n    .refine((id: string) => isMongoId(id), {\n      message: "Please provide a valid id",\n    }),\n  ids: z\n    .array(z.string().refine((id: string) => isMongoId(id), {\n      message: "Each ID must be a valid MongoDB ObjectId",\n    }))\n    .min(1, {\n      message: "At least one ID must be provided",\n    }),\n}).strict();\n\n/**\n * Middleware function to validate '+i+" ID using Zod schema.\n * @param {object} req - The request object.\n * @param {object} res - The response object.\n * @param {function} next - The next middleware function.\n * @returns {void}\n */\nexport const validate"+u+"Id = (req: Request, res: Response, next: NextFunction) => {\n  // Validate request params\n  const { error, success } = zod"+u+"Schema.pick({ id: true }).safeParse({ id: req.params.id });\n\n  // Check if validation was successful\n  if (!success) {\n    // If validation failed, use the Zod error handler to send an error response\n    return zodErrorHandler(req, res, error);\n  }\n\n  // If validation passed, proceed to the next middleware function\n  return next();\n};\n    ",T=path.join(p,i+".validation.ts");fs.writeFileSync(T,S.trim());var $="\n// Import the model\nimport "+u+"Model from '"+(o.exists?Array(c.length+1).fill("..").join("/")+"/"+i+"/"+i+".model":"./"+i+".model")+"';\n/**\n * Service function to create a new "+i+".\n *\n * @param data - The data to create a new "+i+".\n * @returns {Promise<"+u+">} - The created "+i+".\n */\nconst create"+u+" = async (data: object) => {\n  const new"+u+" = new "+u+"Model(data);\n  return await new"+u+".save();\n};\n\n/**\n * Service function to create multiple "+i+"s.\n *\n * @param data - An array of data to create multiple "+i+".\n * @returns {Promise<"+u+"[]>} - The created "+i+".\n */\nconst createMany"+u+" = async (data: object[]) => {\n  return await "+u+"Model.insertMany(data);\n};\n\n/**\n * Service function to update a single "+i+" by ID.\n *\n * @param id - The ID of the "+i+" to update.\n * @param data - The updated data for the "+i+".\n * @returns {Promise<"+u+">} - The updated "+i+".\n */\nconst update"+u+" = async (id: string, data: object) => {\n  return await "+u+"Model.findByIdAndUpdate(id, data, { new: true });\n};\n\n/**\n * Service function to update multiple "+i+".\n *\n * @param data - An array of data to update multiple "+i+".\n * @returns {Promise<"+u+"[]>} - The updated "+i+".\n */\nconst updateMany"+u+" = async (data: { id: string, updates: object }[]) => {\n  const updatePromises = data.map(({ id, updates }) =>\n    "+u+"Model.findByIdAndUpdate(id, updates, { new: true })\n  );\n  return await Promise.all(updatePromises);\n};\n\n/**\n * Service function to delete a single "+i+" by ID.\n *\n * @param id - The ID of the "+i+" to delete.\n * @returns {Promise<"+u+">} - The deleted "+i+".\n */\nconst delete"+u+" = async (id: string) => {\n  return await "+u+"Model.findByIdAndDelete(id);\n};\n\n/**\n * Service function to delete multiple "+i+".\n *\n * @param ids - An array of IDs of "+i+" to delete.\n * @returns {Promise<"+u+"[]>} - The deleted "+i+".\n */\nconst deleteMany"+u+" = async (ids: string[]) => {\n  return await "+u+"Model.deleteMany({ _id: { $in: ids } });\n};\n\n/**\n * Service function to retrieve a single "+i+" by ID.\n *\n * @param id - The ID of the "+i+" to retrieve.\n * @returns {Promise<"+u+">} - The retrieved "+i+".\n */\nconst get"+u+"ById = async (id: string) => {\n  return await "+u+"Model.findById(id);\n};\n\n/**\n * Service function to retrieve multiple "+i+" based on query parameters.\n *\n * @param query - The query parameters for filtering "+i+".\n * @returns {Promise<"+u+"[]>} - The retrieved "+i+".\n */\nconst getMany"+u+" = async (query: object) => {\n  return await "+u+"Model.find(query);\n};\n\nexport const "+d+"Services = {\n  create"+u+",\n  createMany"+u+",\n  update"+u+",\n  updateMany"+u+",\n  delete"+u+",\n  deleteMany"+u+",\n  get"+u+"ById,\n  getMany"+u+",\n};\n\n    ",I=path.join(p,i+".service.ts");fs.writeFileSync(I,$.trim()),console.log(GREEN+"CREATE "+RESET+h(g)+" "+BLUE+"("+Buffer.byteLength(y,"utf8")+" bytes)"),console.log(GREEN+"CREATE "+RESET+h(q)+" "+BLUE+"("+Buffer.byteLength(R,"utf8")+" bytes)"),o.exists||(fs.writeFileSync(b,v.trim()),console.log(GREEN+"CREATE "+RESET+h(b)+" "+BLUE+"("+Buffer.byteLength(v,"utf8")+" bytes)")),console.log(GREEN+"CREATE "+RESET+h(f)+" "+BLUE+"("+Buffer.byteLength(m,"utf8")+" bytes)"),console.log(GREEN+"CREATE "+RESET+h(I)+" "+BLUE+"("+Buffer.byteLength($,"utf8")+" bytes)"),console.log(GREEN+"CREATE "+RESET+h(T)+" "+BLUE+"("+Buffer.byteLength(S,"utf8")+" bytes)")}).bind(this)),program.parse(process.argv)):(console.error("Unknown command: "+command),process.exit(1));