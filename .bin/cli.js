#!/usr/bin/env node
function _toConsumableArray(e){return _arrayWithoutHoles(e)||_iterableToArray(e)||_unsupportedIterableToArray(e)||_nonIterableSpread()}function _nonIterableSpread(){throw TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _arrayWithoutHoles(e){if(Array.isArray(e))return _arrayLikeToArray(e)}function _createForOfIteratorHelper(e,n){var t="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!t){if(Array.isArray(e)||(t=_unsupportedIterableToArray(e))||n&&e&&"number"==typeof e.length){t&&(e=t);var a=0,c=function e(){};return{s:c,n:function n(){return a>=e.length?{done:!0}:{done:!1,value:e[a++]}},e:function e(n){throw n},f:c}}throw TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,r=!0,s=!1;return{s:function n(){t=t.call(e)},n:function e(){var n=t.next();return r=n.done,n},e:function e(n){s=!0,o=n},f:function e(){try{r||null==t.return||t.return()}finally{if(s)throw o}}}}function _toArray(e){return _arrayWithHoles(e)||_iterableToArray(e)||_unsupportedIterableToArray(e)||_nonIterableRest()}function _nonIterableRest(){throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _unsupportedIterableToArray(e,n){if(e){if("string"==typeof e)return _arrayLikeToArray(e,n);var t=({}).toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?_arrayLikeToArray(e,n):void 0}}function _arrayLikeToArray(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}function _iterableToArray(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}function _arrayWithHoles(e){if(Array.isArray(e))return e}var _process$argv=_toArray(process.argv),command=_process$argv[2],args=_process$argv.slice(3),fs=require("fs"),path=require("path"),_require=require("commander"),program=_require.program,GREEN="\x1b[32m",BLUE="\x1b[34m",RESET="\x1b[0m",specialCharRegex=/[0-9!@#$%^&*()_+{}\[\]:;"'<>,.?/~`|\-=\s]/g;function capitalize(e){return e.charAt(0).toUpperCase()+e.slice(1)}function toCamelCase(e){return e.replace(/[^a-zA-Z]+/g,"-").replace(/^-+|-+$/g,"").split("-").map(function(e,n){return 0===n?e.toLowerCase():e.charAt(0).toUpperCase()+e.slice(1).toLowerCase()}).join("")}"resource"===command?(program.version("1.0.0").description("Generate route, model, controller, and interface files for a new resource").argument("<name>","Resource name").action(function(e){var n,t,a,c=specialCharRegex.test(args[0])?toCamelCase(args[0]):args[0].toLowerCase(),o="".concat(args[0],".model.ts"),r=(process.argv.slice(2),(a=function e(n){var t,a=fs.readdirSync(n),c=_createForOfIteratorHelper(a);try{for(c.s();!(t=c.n()).done;){var r=t.value,s=path.join(n,r);if(fs.statSync(s).isDirectory()){var i=e(s);if(i)return i}else if(r===o)return s}}catch(d){c.e(d)}finally{c.f()}return null}(path.join(process.cwd(),"src")))?{exists:!0,filePath:a}:{exists:!1,filePath:null}),s=capitalize(c),i=path.join(__dirname,"..","src","modules",args[0]),d=path.join(__dirname,"..","src","modules",args[0]),l=path.join(__dirname,"..","src","modules",args[0]),u=path.join(__dirname,"..","src","modules",args[0]),p=path.join(__dirname,"..","src","modules",args[0]),m=path.join(__dirname,"..","src","modules",args[0]),h=function e(n){return path.relative(path.join(__dirname,".."),n)};[i,d,u,l].forEach(function(e){fs.existsSync(e)||fs.mkdirSync(e,{recursive:!0})});var f="\n// Import Router from express\nimport { Router } from 'express';\n\n// Import controller from corresponding module\nimport { \n  create".concat(s,",\n  createMany").concat(s,",\n  update").concat(s,",\n  updateMany").concat(s,",\n  delete").concat(s,",\n  deleteMany").concat(s,",\n  get").concat(s,"ById,\n  getMany").concat(s,"\n} from './").concat(args[0],".controller';\n\n//Import validation from corresponding module\nimport { validate").concat(s," } from './").concat(args[0],".validation';\nimport { validateId, validateIds } from '../../handlers/common-zod-validator';\n\n// Initialize router\nconst router = Router();\n\n// Define route handlers\n/**\n * @route POST /api/v1/").concat(args[0],"/create-").concat(args[0],"\n * @description Create a new ").concat(args[0],"\n * @access Public\n * @param {function} controller - ['create").concat(s,"']\n * @param {function} validation - ['validate").concat(s,"']\n */\nrouter.post(\"/create-").concat(args[0],'", validate').concat(s,", create").concat(s,");\n\n/**\n * @route POST /api/v1/").concat(args[0],"/create-").concat(args[0],"/many\n * @description Create multiple ").concat(args[0],"\n * @access Public\n * @param {function} controller - ['createMany").concat(s,"']\n */\nrouter.post(\"/create-").concat(args[0],'/many", createMany').concat(s,");\n\n/**\n * @route PUT /api/v1/").concat(args[0],"/update-").concat(args[0],"/many\n * @description Update multiple ").concat(args[0]," information\n * @access Public\n * @param {function} controller - ['updateMany").concat(s,"']\n * @param {function} validation - ['validateIds']\n */\nrouter.put(\"/update-").concat(args[0],'/many", validateIds, updateMany').concat(s,");\n\n/**\n * @route PUT /api/v1/").concat(args[0],"/update-").concat(args[0],"/:id\n * @description Update ").concat(args[0]," information\n * @param {string} id - The ID of the ").concat(args[0]," to update\n * @access Public\n * @param {function} controller - ['update").concat(s,"']\n * @param {function} validation - ['validateId', 'validate").concat(s,"']\n */\nrouter.put(\"/update-").concat(args[0],'/:id", validateId, validate').concat(s,", update").concat(s,");\n\n/**\n * @route DELETE /api/v1/").concat(args[0],"/delete-").concat(args[0],"/many\n * @description Delete multiple ").concat(args[0],"\n * @access Public\n * @param {function} controller - ['deleteMany").concat(s,"']\n * @param {function} validation - ['validateIds']\n */\nrouter.delete(\"/delete-").concat(args[0],'/many", validateIds, deleteMany').concat(s,");\n\n/**\n * @route DELETE /api/v1/").concat(args[0],"/delete-").concat(args[0],"/:id\n * @description Delete a ").concat(args[0],"\n * @param {string} id - The ID of the ").concat(args[0]," to delete\n * @access Public\n * @param {function} controller - ['delete").concat(s,"']\n * @param {function} validation - ['validateId']\n */\nrouter.delete(\"/delete-").concat(args[0],'/:id", validateId, delete').concat(s,");\n\n/**\n * @route GET /api/v1/").concat(args[0],"/get-").concat(args[0],"/many\n * @description Get multiple ").concat(args[0],"\n * @access Public\n * @param {function} controller - ['getMany").concat(s,"']\n * @param {function} validation - ['validateIds']\n */\nrouter.get(\"/get-").concat(args[0],'/many", validateIds, getMany').concat(s,");\n\n/**\n * @route GET /api/v1/").concat(args[0],"/get-").concat(args[0],"/:id\n * @description Get a ").concat(args[0]," by ID\n * @param {string} id - The ID of the ").concat(args[0]," to retrieve\n * @access Public\n * @param {function} controller - ['get").concat(s,"ById']\n * @param {function} validation - ['validateId']\n */\nrouter.get(\"/get-").concat(args[0],'/:id", validateId, get').concat(s,"ById);\n\n// Export the router\nmodule.exports = router;\n    "),y=path.join(i,"".concat(args[0],".route.ts"));fs.writeFileSync(y,f.trim());var g="\nimport { Request, Response } from 'express';\nimport { ".concat(c,"Services } from './").concat(args[0],".service';\nimport ServerResponse from '../../helpers/responses/custom-response';\nimport catchAsync from '../../utils/catch-async/catch-async';\n\n/**\n * Controller function to handle the creation of a single ").concat(s,".\n *\n * @param {Request} req - The request object containing ").concat(args[0]," data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const create").concat(s," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to create a new ").concat(args[0]," and get the result\n  const result = await ").concat(c,"Services.create").concat(s,"(req.body);\n  // Send a success response with the created resource data\n  ServerResponse(res, true, 201, '").concat(s," created successfully', result);\n});\n\n/**\n * Controller function to handle the creation of multiple ").concat(args[0],".\n *\n * @param {Request} req - The request object containing an array of ").concat(args[0]," data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const createMany").concat(s," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to create multiple ").concat(c,"s and get the result\n  const result = await ").concat(c,"Services.createMany").concat(s,"(req.body);\n  // Send a success response with the created resources data\n  ServerResponse(res, true, 201, 'Resources created successfully', result);\n});\n\n/**\n * Controller function to handle the update operation for a single ").concat(args[0],".\n *\n * @param {Request} req - The request object containing the ID of the ").concat(args[0]," to update in URL parameters and the updated data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const update").concat(s," = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to update the ").concat(args[0]," by ID and get the result\n  const result = await ").concat(c,"Services.update").concat(s,"(id, req.body);\n  // Send a success response with the updated resource data\n  ServerResponse(res, true, 200, '").concat(s," updated successfully', result);\n});\n\n/**\n * Controller function to handle the update operation for multiple ").concat(args[0],".\n *\n * @param {Request} req - The request object containing an array of ").concat(args[0]," data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const updateMany").concat(s," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to update multiple ").concat(args[0]," and get the result\n  const result = await ").concat(c,"Services.updateMany").concat(s,"(req.body);\n  // Send a success response with the updated resources data\n  ServerResponse(res, true, 200, 'Resources updated successfully', result);\n});\n\n/**\n * Controller function to handle the deletion of a single ").concat(args[0],".\n *\n * @param {Request} req - The request object containing the ID of the ").concat(args[0]," to delete in URL parameters.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const delete").concat(s," = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to delete the ").concat(args[0]," by ID\n  await ").concat(c,"Services.delete").concat(s,"(id);\n  // Send a success response confirming the deletion\n  ServerResponse(res, true, 200, '").concat(s," deleted successfully');\n});\n\n/**\n * Controller function to handle the deletion of multiple ").concat(args[0],".\n *\n * @param {Request} req - The request object containing an array of IDs of ").concat(args[0]," to delete in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const deleteMany").concat(s," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to delete multiple ").concat(args[0]," and get the result\n  await ").concat(c,"Services.deleteMany").concat(s,"(req.body);\n  // Send a success response confirming the deletions\n  ServerResponse(res, true, 200, 'Resources deleted successfully');\n});\n\n/**\n * Controller function to handle the retrieval of a single ").concat(args[0]," by ID.\n *\n * @param {Request} req - The request object containing the ID of the ").concat(args[0]," to retrieve in URL parameters.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const get").concat(s,"ById = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to get the ").concat(args[0]," by ID and get the result\n  const result = await ").concat(c,"Services.get").concat(s,"ById(id);\n  // Send a success response with the retrieved resource data\n  ServerResponse(res, true, 200, '").concat(s," retrieved successfully', result);\n});\n\n/**\n * Controller function to handle the retrieval of multiple ").concat(args[0],".\n *\n * @param {Request} req - The request object containing query parameters for filtering.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const getMany").concat(s," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to get multiple ").concat(args[0]," based on query parameters and get the result\n  const result = await ").concat(c,"Services.getMany").concat(s,"(req.query);\n  // Send a success response with the retrieved resources data\n  ServerResponse(res, true, 200, 'Resources retrieved successfully', result);\n});\n    "),v=path.join(d,"".concat(args[0],".controller.ts"));fs.writeFileSync(v,g.trim());var b="\nimport mongoose, { Document, Schema } from 'mongoose';\n\n// Define an interface representing a ".concat(s," document\ninterface I").concat(s," extends Document {\n  // Define the schema fields with their types\n  // Example fields (replace with actual fields)\n  // fieldName: fieldType;\n}\n\n// Define the ").concat(s," schema\nconst ").concat(s,"Schema: Schema<I").concat(s,"> = new Schema({\n  // Define schema fields here\n  // Example fields (replace with actual schema)\n  // fieldName: {\n  //   type: Schema.Types.FieldType,\n  //   required: true,\n  //   trim: true,\n  // },\n});\n\n// Create the ").concat(s," model\nconst ").concat(s," = mongoose.model<I").concat(s,">('").concat(s,"', ").concat(s,"Schema);\n\n// Export the ").concat(s," model\nexport default ").concat(s,";\n    "),R=path.join(u,"".concat(args[0],".model.ts"));r.exists||fs.writeFileSync(R,b.trim());var q="\n/**\n * Type definition for ".concat(s,".\n *\n * This type defines the structure of a single ").concat(c," object.\n * @interface T").concat(s,"\n */\nexport interface T").concat(s," {\n  // Add fields as needed\n}\n    "),T=path.join(l,"".concat(args[0],".interface.ts"));fs.writeFileSync(T,q.trim());var S="\nimport { NextFunction, Request, Response } from 'express';\nimport { z } from 'zod';\nimport zodErrorHandler from '../../handlers/zod-error-handler';\n\n/**\n * Zod schema for validating ".concat(c," data.\n */\nconst zod").concat(s,"Schema = z.object({\n // Define schema fields here\n}).strict();\n\n/**\n * Middleware function to validate ").concat(c," using Zod schema.\n * @param {object} req - The request object.\n * @param {object} res - The response object.\n * @param {function} next - The next middleware function.\n * @returns {void}\n */\nexport const validate").concat(s," = (req: Request, res: Response, next: NextFunction) => {\n  // Validate request body\n  const { error, success } = zod").concat(s,"Schema.safeParse(req.body);\n\n  // Check if validation was successful\n  if (!success) {\n    // If validation failed, use the Zod error handler to send an error response\n    return zodErrorHandler(req, res, error);\n  }\n\n  // If validation passed, proceed to the next middleware function\n  return next();\n};\n    "),$=path.join(p,"".concat(args[0],".validation.ts"));fs.writeFileSync($,S.trim());var I=null==r||null===(n=r.filePath)||void 0===n?void 0:n.substring(r.filePath.indexOf("modules")+7+1),E="\n// Import the model\nimport ".concat(s,"Model from '").concat(r.exists?"../".concat(I.replace(/\\/g,"/").replace(/\.ts$/,"")):"./".concat(args[0],".model"),"';\n\n/**\n * Service function to create a new ").concat(c,".\n *\n * @param data - The data to create a new ").concat(c,".\n * @returns {Promise<").concat(s,">} - The created ").concat(c,".\n */\nconst create").concat(s," = async (data: object) => {\n  const new").concat(s," = new ").concat(s,"Model(data);\n  return await new").concat(s,".save();\n};\n\n/**\n * Service function to create multiple ").concat(c,".\n *\n * @param data - An array of data to create multiple ").concat(c,".\n * @returns {Promise<").concat(s,"[]>} - The created ").concat(c,".\n */\nconst createMany").concat(s," = async (data: object[]) => {\n  return await ").concat(s,"Model.insertMany(data);\n};\n\n/**\n * Service function to update a single ").concat(c," by ID.\n *\n * @param id - The ID of the ").concat(c," to update.\n * @param data - The updated data for the ").concat(c,".\n * @returns {Promise<").concat(s,">} - The updated ").concat(c,".\n */\nconst update").concat(s," = async (id: string, data: object) => {\n  return await ").concat(s,"Model.findByIdAndUpdate(id, data, { new: true });\n};\n\n/**\n * Service function to update multiple ").concat(c,".\n *\n * @param data - An array of data to update multiple ").concat(c,".\n * @returns {Promise<").concat(s,"[]>} - The updated ").concat(c,".\n */\nconst updateMany").concat(s," = async (data: { id: string, updates: object }[]) => {\n  const updatePromises = data.map(({ id, updates }) =>\n    ").concat(s,"Model.findByIdAndUpdate(id, updates, { new: true })\n  );\n  return await Promise.all(updatePromises);\n};\n\n/**\n * Service function to delete a single ").concat(c," by ID.\n *\n * @param id - The ID of the ").concat(c," to delete.\n * @returns {Promise<").concat(s,">} - The deleted ").concat(c,".\n */\nconst delete").concat(s," = async (id: string) => {\n  return await ").concat(s,"Model.findByIdAndDelete(id);\n};\n\n/**\n * Service function to delete multiple ").concat(c,".\n *\n * @param ids - An array of IDs of ").concat(c," to delete.\n * @returns {Promise<").concat(s,"[]>} - The deleted ").concat(c,".\n */\nconst deleteMany").concat(s," = async (ids: string[]) => {\n  return await ").concat(s,"Model.deleteMany({ _id: { $in: ids } });\n};\n\n/**\n * Service function to retrieve a single ").concat(c," by ID.\n *\n * @param id - The ID of the ").concat(c," to retrieve.\n * @returns {Promise<").concat(s,">} - The retrieved ").concat(c,".\n */\nconst get").concat(s,"ById = async (id: string) => {\n  return await ").concat(s,"Model.findById(id);\n};\n\n/**\n * Service function to retrieve multiple ").concat(c," based on query parameters.\n *\n * @param query - The query parameters for filtering ").concat(c,".\n * @returns {Promise<").concat(s,"[]>} - The retrieved ").concat(c,".\n */\nconst getMany").concat(s," = async (query: object) => {\n  return await ").concat(s,"Model.find(query);\n};\n\nexport const ").concat(c,"Services = {\n  create").concat(s,",\n  createMany").concat(s,",\n  update").concat(s,",\n  updateMany").concat(s,",\n  delete").concat(s,",\n  deleteMany").concat(s,",\n  get").concat(s,"ById,\n  getMany").concat(s,",\n};\n\n    "),w=path.join(m,"".concat(args[0],".service.ts"));fs.writeFileSync(w,E.trim()),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(h(v)," ").concat(BLUE,"(").concat(Buffer.byteLength(g,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(h(T)," ").concat(BLUE,"(").concat(Buffer.byteLength(q,"utf8")," bytes)")),r.exists||console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(h(R)," ").concat(BLUE,"(").concat(Buffer.byteLength(b,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(h(y)," ").concat(BLUE,"(").concat(Buffer.byteLength(f,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(h(w)," ").concat(BLUE,"(").concat(Buffer.byteLength(E,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(h($)," ").concat(BLUE,"(").concat(Buffer.byteLength(S,"utf8")," bytes)"))}),program.parse(process.argv)):"nested-resource"===command?(program.version("1.0.0").description("Generate nested route, model, controller, and interface files for a new resource").argument("<path>","Nested path to resource (e.g., folder1/folder2/resourceName)").action(function(e){var n,t,a=args[0].split("/"),c=a[a.length-1],o="".concat(c,".model.ts"),r=(process.argv.slice(2),(t=function e(n){var t,a=fs.readdirSync(n),c=_createForOfIteratorHelper(a);try{for(c.s();!(t=c.n()).done;){var r=t.value,s=path.join(n,r);if(fs.statSync(s).isDirectory()){var i=e(s);if(i)return i}else if(r===o)return s}}catch(d){c.e(d)}finally{c.f()}return null}(path.join(process.cwd(),"src")))?{exists:!0,filePath:t}:{exists:!1,filePath:null}),s=a.pop(),i=specialCharRegex.test(args[0])?toCamelCase(s):s.toLowerCase(),d=a,l=capitalize(i),u=path.join(__dirname,"..","src"),p=path.join.apply(path,[u,"modules"].concat(_toConsumableArray(d),[s])),m=function e(n){return path.relative(path.join(__dirname,".."),n)};fs.existsSync(p)||fs.mkdirSync(p,{recursive:!0});var h="\n// Import Router from express\nimport { Router } from 'express';\n\n// Import controller from corresponding module\nimport { \n  create".concat(l,",\n  createMany").concat(l,",\n  update").concat(l,",\n  updateMany").concat(l,",\n  delete").concat(l,",\n  deleteMany").concat(l,",\n  get").concat(l,"ById,\n  getMany").concat(l,"\n} from './").concat(s,".controller';\n\n//Import validation from corresponding module\nimport { validate").concat(l," } from './").concat(s,".validation';\nimport { validateId, validateIds } from '").concat(Array(d.length+2).fill("..").join("/"),"/handlers/common-zod-validator';\n      \n// Initialize router\nconst router = Router();\n\n// Define route handlers\n/**\n * @route POST /api/v1/").concat(d.join("/"),"/").concat(s,"/create-").concat(s,"\n * @description Create a new ").concat(s,"\n * @access Public\n * @param {function} controller - ['create").concat(l,"']\n * @param {function} validation - ['validate").concat(l,"']\n */\nrouter.post(\"/create-").concat(s,'", validate').concat(l,", create").concat(l,");\n\n/**\n * @route POST /api/v1/").concat(d.join("/"),"/").concat(s,"/create-").concat(s,"/many\n * @description Create multiple ").concat(s,"\n * @access Public\n * @param {function} controller - ['createMany").concat(l,"']\n */\nrouter.post(\"/create-").concat(s,'/many", createMany').concat(l,");\n\n/**\n * @route PUT /api/v1/").concat(d.join("/"),"/").concat(s,"/update-").concat(s,"/many\n * @description Update multiple ").concat(s," information\n * @access Public\n * @param {function} controller - ['updateMany").concat(l,"']\n * @param {function} validation - ['validateIds']\n */\nrouter.put(\"/update-").concat(s,'/many", validateIds, updateMany').concat(l,");\n\n/**\n * @route PUT /api/v1/").concat(d.join("/"),"/").concat(s,"/update-").concat(s,"/:id\n * @description Update ").concat(s," information\n * @param {string} id - The ID of the ").concat(s," to update\n * @access Public\n * @param {function} controller - ['update").concat(l,"']\n * @param {function} validation - ['validateId', 'validate").concat(l,"']\n */\nrouter.put(\"/update-").concat(s,'/:id", validateId, validate').concat(l,", update").concat(l,");\n\n/**\n * @route DELETE /api/v1/").concat(d.join("/"),"/").concat(s,"/delete-").concat(s,"/many\n * @description Delete multiple ").concat(s,"\n * @access Public\n * @param {function} controller - ['deleteMany").concat(l,"']\n * @param {function} validation - ['validateIds']\n */\nrouter.delete(\"/delete-").concat(s,'/many", validateIds, deleteMany').concat(l,");\n\n/**\n * @route DELETE /api/v1/").concat(d.join("/"),"/").concat(s,"/delete-").concat(s,"/:id\n * @description Delete a ").concat(s,"\n * @param {string} id - The ID of the ").concat(s," to delete\n * @access Public\n * @param {function} controller - ['delete").concat(l,"']\n * @param {function} validation - ['validateId']\n */\nrouter.delete(\"/delete-").concat(s,'/:id", validateId, delete').concat(l,");\n\n/**\n * @route GET /api/v1/").concat(d.join("/"),"/").concat(s,"/get-").concat(s,"/many\n * @description Get multiple ").concat(s,"\n * @access Public\n * @param {function} controller - ['getMany").concat(l,"']\n * @param {function} validation - ['validateIds']\n */\nrouter.get(\"/get-").concat(s,'/many", validateIds, getMany').concat(l,");\n\n/**\n * @route GET /api/v1/").concat(d.join("/"),"/").concat(s,"/get-").concat(s,"/:id\n * @description Get a ").concat(s," by ID\n * @param {string} id - The ID of the ").concat(s," to retrieve\n * @access Public\n * @param {function} controller - ['get").concat(l,"ById']\n * @param {function} validation - ['validateId']\n */\nrouter.get(\"/get-").concat(s,'/:id", validateId, get').concat(l,"ById);\n\n// Export the router\nmodule.exports = router;\n    "),f=path.join(p,"".concat(s,".route.ts"));fs.writeFileSync(f,h.trim());var y="\nimport { Request, Response } from 'express';\nimport { ".concat(i,"Services } from './").concat(s,".service';\nimport ServerResponse from '").concat(Array(d.length+2).fill("..").join("/"),"/helpers/responses/custom-response';\nimport catchAsync from '").concat(Array(d.length+2).fill("..").join("/"),"/utils/catch-async/catch-async';\n\n/**\n * Controller function to handle the creation of a single ").concat(l,".\n *\n * @param {Request} req - The request object containing ").concat(s," data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const create").concat(l," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to create a new ").concat(s," and get the result\n  const result = await ").concat(i,"Services.create").concat(l,"(req.body);\n  // Send a success response with the created resource data\n  ServerResponse(res, true, 201, '").concat(l," created successfully', result);\n});\n\n/**\n * Controller function to handle the creation of multiple ").concat(s,".\n *\n * @param {Request} req - The request object containing an array of ").concat(s," data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const createMany").concat(l," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to create multiple ").concat(s," and get the result\n  const result = await ").concat(i,"Services.createMany").concat(l,"(req.body);\n  // Send a success response with the created resources data\n  ServerResponse(res, true, 201, 'Resources created successfully', result);\n});\n\n/**\n * Controller function to handle the update operation for a single ").concat(l,".\n *\n * @param {Request} req - The request object containing the ID of the ").concat(s," to update in URL parameters and the updated data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const update").concat(l," = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to update the ").concat(s," by ID and get the result\n  const result = await ").concat(i,"Services.update").concat(l,"(id, req.body);\n  // Send a success response with the updated resource data\n  ServerResponse(res, true, 200, '").concat(l," updated successfully', result);\n});\n\n/**\n * Controller function to handle the update operation for multiple ").concat(s,".\n *\n * @param {Request} req - The request object containing an array of ").concat(s," data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const updateMany").concat(l," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to update multiple ").concat(s," and get the result\n  const result = await ").concat(i,"Services.updateMany").concat(l,"(req.body);\n  // Send a success response with the updated resources data\n  ServerResponse(res, true, 200, 'Resources updated successfully', result);\n});\n\n/**\n * Controller function to handle the deletion of a single ").concat(l,".\n *\n * @param {Request} req - The request object containing the ID of the ").concat(s," to delete in URL parameters.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const delete").concat(l," = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to delete the ").concat(s," by ID\n  await ").concat(i,"Services.delete").concat(l,"(id);\n  // Send a success response confirming the deletion\n  ServerResponse(res, true, 200, '").concat(l," deleted successfully');\n});\n\n/**\n * Controller function to handle the deletion of multiple ").concat(s,".\n *\n * @param {Request} req - The request object containing an array of IDs of ").concat(s," to delete in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const deleteMany").concat(l," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to delete multiple ").concat(s," and get the result\n  await ").concat(i,"Services.deleteMany").concat(l,"(req.body);\n  // Send a success response confirming the deletions\n  ServerResponse(res, true, 200, 'Resources deleted successfully');\n});\n\n/**\n * Controller function to handle the retrieval of a single ").concat(l," by ID.\n *\n * @param {Request} req - The request object containing the ID of the ").concat(s," to retrieve in URL parameters.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const get").concat(l,"ById = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to get the ").concat(s," by ID and get the result\n  const result = await ").concat(i,"Services.get").concat(l,"ById(id);\n  // Send a success response with the retrieved resource data\n  ServerResponse(res, true, 200, '").concat(l," retrieved successfully', result);\n});\n\n/**\n * Controller function to handle the retrieval of multiple ").concat(s,".\n *\n * @param {Request} req - The request object containing query parameters for filtering.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const getMany").concat(l," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to get multiple ").concat(s," based on query parameters and get the result\n  const result = await ").concat(i,"Services.getMany").concat(l,"(req.query);\n  // Send a success response with the retrieved resources data\n  ServerResponse(res, true, 200, 'Resources retrieved successfully', result);\n});\n    "),g=path.join(p,"".concat(s,".controller.ts"));fs.writeFileSync(g,y.trim());var v="\nimport mongoose, { Document, Schema } from 'mongoose';\n\ninterface I".concat(l," extends Document {\n  // Define the schema fields with their types\n}\n\nconst ").concat(l,"Schema: Schema<I").concat(l,"> = new Schema({\n  // Define schema fields here\n});\n\nconst ").concat(l," = mongoose.model<I").concat(l,">('").concat(l,"', ").concat(l,"Schema);\n\nexport default ").concat(l,";\n    "),b=path.join(p,"".concat(s,".model.ts"));r.exists||fs.writeFileSync(b,v.trim());var R="\nexport interface T".concat(l," {\n  // Add fields as needed\n}\n    "),q=path.join(p,"".concat(s,".interface.ts"));fs.writeFileSync(q,R.trim());var T="\nimport { NextFunction, Request, Response } from 'express';\nimport { z } from 'zod';\nimport zodErrorHandler from '".concat(Array(d.length+2).fill("..").join("/"),"/handlers/zod-error-handler';\n\n/**\n * Zod schema for validating ").concat(s," data.\n */\nconst zod").concat(l,"Schema = z.object({\n  // Define schema fields here\n}).strict();\n\n/**\n * Middleware function to validate ").concat(s," using Zod schema.\n * @param {object} req - The request object.\n * @param {object} res - The response object.\n * @param {function} next - The next middleware function.\n * @returns {void}\n */\nexport const validate").concat(l," = (req: Request, res: Response, next: NextFunction) => {\n  // Validate request body\n  const { error, success } = zod").concat(l,"Schema.safeParse(req.body);\n\n  // Check if validation was successful\n  if (!success) {\n    // If validation failed, use the Zod error handler to send an error response\n    return zodErrorHandler(req, res, error);\n  }\n\n  // If validation passed, proceed to the next middleware function\n  return next();\n};\n\n"),S=path.join(p,"".concat(s,".validation.ts"));fs.writeFileSync(S,T.trim());var $="\n// Import the model\nimport ".concat(l,"Model from '").concat(r.exists?"".concat(Array(d.length+1).fill("..").join("/"),"/").concat(s,"/").concat(s,".model"):"./".concat(s,".model"),"';\n/**\n * Service function to create a new ").concat(s,".\n *\n * @param data - The data to create a new ").concat(s,".\n * @returns {Promise<").concat(l,">} - The created ").concat(s,".\n */\nconst create").concat(l," = async (data: object) => {\n  const new").concat(l," = new ").concat(l,"Model(data);\n  return await new").concat(l,".save();\n};\n\n/**\n * Service function to create multiple ").concat(s,"s.\n *\n * @param data - An array of data to create multiple ").concat(s,".\n * @returns {Promise<").concat(l,"[]>} - The created ").concat(s,".\n */\nconst createMany").concat(l," = async (data: object[]) => {\n  return await ").concat(l,"Model.insertMany(data);\n};\n\n/**\n * Service function to update a single ").concat(s," by ID.\n *\n * @param id - The ID of the ").concat(s," to update.\n * @param data - The updated data for the ").concat(s,".\n * @returns {Promise<").concat(l,">} - The updated ").concat(s,".\n */\nconst update").concat(l," = async (id: string, data: object) => {\n  return await ").concat(l,"Model.findByIdAndUpdate(id, data, { new: true });\n};\n\n/**\n * Service function to update multiple ").concat(s,".\n *\n * @param data - An array of data to update multiple ").concat(s,".\n * @returns {Promise<").concat(l,"[]>} - The updated ").concat(s,".\n */\nconst updateMany").concat(l," = async (data: { id: string, updates: object }[]) => {\n  const updatePromises = data.map(({ id, updates }) =>\n    ").concat(l,"Model.findByIdAndUpdate(id, updates, { new: true })\n  );\n  return await Promise.all(updatePromises);\n};\n\n/**\n * Service function to delete a single ").concat(s," by ID.\n *\n * @param id - The ID of the ").concat(s," to delete.\n * @returns {Promise<").concat(l,">} - The deleted ").concat(s,".\n */\nconst delete").concat(l," = async (id: string) => {\n  return await ").concat(l,"Model.findByIdAndDelete(id);\n};\n\n/**\n * Service function to delete multiple ").concat(s,".\n *\n * @param ids - An array of IDs of ").concat(s," to delete.\n * @returns {Promise<").concat(l,"[]>} - The deleted ").concat(s,".\n */\nconst deleteMany").concat(l," = async (ids: string[]) => {\n  return await ").concat(l,"Model.deleteMany({ _id: { $in: ids } });\n};\n\n/**\n * Service function to retrieve a single ").concat(s," by ID.\n *\n * @param id - The ID of the ").concat(s," to retrieve.\n * @returns {Promise<").concat(l,">} - The retrieved ").concat(s,".\n */\nconst get").concat(l,"ById = async (id: string) => {\n  return await ").concat(l,"Model.findById(id);\n};\n\n/**\n * Service function to retrieve multiple ").concat(s," based on query parameters.\n *\n * @param query - The query parameters for filtering ").concat(s,".\n * @returns {Promise<").concat(l,"[]>} - The retrieved ").concat(s,".\n */\nconst getMany").concat(l," = async (query: object) => {\n  return await ").concat(l,"Model.find(query);\n};\n\nexport const ").concat(i,"Services = {\n  create").concat(l,",\n  createMany").concat(l,",\n  update").concat(l,",\n  updateMany").concat(l,",\n  delete").concat(l,",\n  deleteMany").concat(l,",\n  get").concat(l,"ById,\n  getMany").concat(l,",\n};\n\n    "),I=path.join(p,"".concat(s,".service.ts"));fs.writeFileSync(I,$.trim()),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(m(g)," ").concat(BLUE,"(").concat(Buffer.byteLength(y,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(m(q)," ").concat(BLUE,"(").concat(Buffer.byteLength(R,"utf8")," bytes)")),r.exists||(fs.writeFileSync(b,v.trim()),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(m(b)," ").concat(BLUE,"(").concat(Buffer.byteLength(v,"utf8")," bytes)"))),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(m(f)," ").concat(BLUE,"(").concat(Buffer.byteLength(h,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(m(I)," ").concat(BLUE,"(").concat(Buffer.byteLength($,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(m(S)," ").concat(BLUE,"(").concat(Buffer.byteLength(T,"utf8")," bytes)"))}),program.parse(process.argv)):(console.error("Unknown command: ".concat(command)),process.exit(1));