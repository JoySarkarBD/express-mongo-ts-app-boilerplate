#!/usr/bin/env node
function _toConsumableArray(e){return _arrayWithoutHoles(e)||_iterableToArray(e)||_unsupportedIterableToArray(e)||_nonIterableSpread()}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _arrayWithoutHoles(e){if(Array.isArray(e))return _arrayLikeToArray(e)}function _createForOfIteratorHelper(e,n){var t="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!t){if(Array.isArray(e)||(t=_unsupportedIterableToArray(e))||n&&e&&"number"==typeof e.length){t&&(e=t);var a=0,n=function(){};return{s:n,n:function(){return a>=e.length?{done:!0}:{done:!1,value:e[a++]}},e:function(e){throw e},f:n}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var c,o=!0,r=!1;return{s:function(){t=t.call(e)},n:function(){var e=t.next();return o=e.done,e},e:function(e){r=!0,c=e},f:function(){try{o||null==t.return||t.return()}finally{if(r)throw c}}}}function _toArray(e){return _arrayWithHoles(e)||_iterableToArray(e)||_unsupportedIterableToArray(e)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _unsupportedIterableToArray(e,n){if(e){if("string"==typeof e)return _arrayLikeToArray(e,n);var t={}.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?_arrayLikeToArray(e,n):void 0}}function _arrayLikeToArray(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}function _iterableToArray(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}function _arrayWithHoles(e){if(Array.isArray(e))return e}var _process$argv=_toArray(process.argv),command=_process$argv[2],args=_process$argv.slice(3),fs=require("fs"),path=require("path"),_require=require("commander"),program=_require.program,GREEN="[32m",BLUE="[34m",RESET="[0m",specialCharRegex=/[0-9!@#$%^&*()_+{}\[\]:;"'<>,.?/~`|\-=\s]/g;function capitalize(e){return e.charAt(0).toUpperCase()+e.slice(1)}function toCamelCase(e){return e.replace(/[^a-zA-Z]+/g,"-").replace(/^-+|-+$/g,"").split("-").map(function(e,n){return 0===n?e.toLowerCase():e.charAt(0).toUpperCase()+e.slice(1).toLowerCase()}).join("")}"resource"===command?(program.version("1.0.0").description("Generate route, model, controller, and interface files for a new resource").argument("<name>","Resource name").action(function(e){var n=specialCharRegex.test(args[0])?toCamelCase(args[0]):args[0].toLowerCase(),r="".concat(args[0],".model.ts");function t(e){return path.relative(path.join(__dirname,".."),e)}var a,c=(process.argv.slice(2),(a=function e(n){var t=_createForOfIteratorHelper(fs.readdirSync(n));try{for(t.s();!(o=t.n()).done;){var a=o.value,c=path.join(n,a);if(fs.statSync(c).isDirectory()){var o=e(c);if(o)return o}else if(a===r)return c}}catch(e){t.e(e)}finally{t.f()}return null}(path.join(process.cwd(),"src")))?{exists:!0,filePath:a}:{exists:!1,filePath:null}),o=capitalize(n),s=path.join(__dirname,"..","src","modules",args[0]),i=path.join(__dirname,"..","src","modules",args[0]),d=path.join(__dirname,"..","src","modules",args[0]),l=path.join(__dirname,"..","src","modules",args[0]),u=path.join(__dirname,"..","src","modules",args[0]),p=path.join(__dirname,"..","src","modules",args[0]);[s,i,l,d].forEach(function(e){fs.existsSync(e)||fs.mkdirSync(e,{recursive:!0})});var h="\n// Import Router from express\nimport { Router } from 'express';\n\n// Import controller from corresponding module\nimport { \n  create".concat(o,",\n  createMany").concat(o,",\n  update").concat(o,",\n  updateMany").concat(o,",\n  delete").concat(o,",\n  deleteMany").concat(o,",\n  get").concat(o,"ById,\n  getMany").concat(o,"\n} from './").concat(args[0],".controller';\n\n//Import validation from corresponding module\nimport { validate").concat(o," } from './").concat(args[0],".validation';\nimport { validateId, validateIds } from '../../handlers/common-zod-validator';\n\n// Initialize router\nconst router = Router();\n\n// Define route handlers\n/**\n * @route POST /api/v1/").concat(args[0],"/create-").concat(args[0],"\n * @description Create a new ").concat(args[0],"\n * @access Public\n * @param {function} controller - ['create").concat(o,"']\n * @param {function} validation - ['validate").concat(o,"']\n */\nrouter.post(\"/create-").concat(args[0],'", validate').concat(o,", create").concat(o,");\n\n/**\n * @route POST /api/v1/").concat(args[0],"/create-").concat(args[0],"/many\n * @description Create multiple ").concat(args[0],"\n * @access Public\n * @param {function} controller - ['createMany").concat(o,"']\n */\nrouter.post(\"/create-").concat(args[0],'/many", createMany').concat(o,");\n\n/**\n * @route PUT /api/v1/").concat(args[0],"/update-").concat(args[0],"/many\n * @description Update multiple ").concat(args[0]," information\n * @access Public\n * @param {function} controller - ['updateMany").concat(o,"']\n * @param {function} validation - ['validateIds']\n */\nrouter.put(\"/update-").concat(args[0],'/many", validateIds, updateMany').concat(o,");\n\n/**\n * @route PUT /api/v1/").concat(args[0],"/update-").concat(args[0],"/:id\n * @description Update ").concat(args[0]," information\n * @param {string} id - The ID of the ").concat(args[0]," to update\n * @access Public\n * @param {function} controller - ['update").concat(o,"']\n * @param {function} validation - ['validateId', 'validate").concat(o,"']\n */\nrouter.put(\"/update-").concat(args[0],'/:id", validateId, validate').concat(o,", update").concat(o,");\n\n/**\n * @route DELETE /api/v1/").concat(args[0],"/delete-").concat(args[0],"/many\n * @description Delete multiple ").concat(args[0],"\n * @access Public\n * @param {function} controller - ['deleteMany").concat(o,"']\n * @param {function} validation - ['validateIds']\n */\nrouter.delete(\"/delete-").concat(args[0],'/many", validateIds, deleteMany').concat(o,");\n\n/**\n * @route DELETE /api/v1/").concat(args[0],"/delete-").concat(args[0],"/:id\n * @description Delete a ").concat(args[0],"\n * @param {string} id - The ID of the ").concat(args[0]," to delete\n * @access Public\n * @param {function} controller - ['delete").concat(o,"']\n * @param {function} validation - ['validateId']\n */\nrouter.delete(\"/delete-").concat(args[0],'/:id", validateId, delete').concat(o,");\n\n/**\n * @route GET /api/v1/").concat(args[0],"/get-").concat(args[0],"/many\n * @description Get multiple ").concat(args[0],"\n * @access Public\n * @param {function} controller - ['getMany").concat(o,"']\n * @param {function} validation - ['validateIds']\n */\nrouter.get(\"/get-").concat(args[0],'/many", validateIds, getMany').concat(o,");\n\n/**\n * @route GET /api/v1/").concat(args[0],"/get-").concat(args[0],"/:id\n * @description Get a ").concat(args[0]," by ID\n * @param {string} id - The ID of the ").concat(args[0]," to retrieve\n * @access Public\n * @param {function} controller - ['get").concat(o,"ById']\n * @param {function} validation - ['validateId']\n */\nrouter.get(\"/get-").concat(args[0],'/:id", validateId, get').concat(o,"ById);\n\n// Export the router\nmodule.exports = router;\n    "),m=path.join(s,"".concat(args[0],".route.ts"));fs.writeFileSync(m,h.trim());var f="\nimport { Request, Response } from 'express';\nimport { ".concat(n,"Services } from './").concat(args[0],".service';\nimport ServerResponse from '../../helpers/responses/custom-response';\nimport catchAsync from '../../utils/catch-async/catch-async';\n\n/**\n * Controller function to handle the creation of a single ").concat(o,".\n *\n * @param {Request} req - The request object containing ").concat(args[0]," data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const create").concat(o," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to create a new ").concat(args[0]," and get the result\n  const result = await ").concat(n,"Services.create").concat(o,"(req.body);\n  // Send a success response with the created resource data\n  ServerResponse(res, true, 201, '").concat(o," created successfully', result);\n});\n\n/**\n * Controller function to handle the creation of multiple ").concat(args[0],".\n *\n * @param {Request} req - The request object containing an array of ").concat(args[0]," data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const createMany").concat(o," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to create multiple ").concat(n,"s and get the result\n  const result = await ").concat(n,"Services.createMany").concat(o,"(req.body);\n  // Send a success response with the created resources data\n  ServerResponse(res, true, 201, 'Resources created successfully', result);\n});\n\n/**\n * Controller function to handle the update operation for a single ").concat(args[0],".\n *\n * @param {Request} req - The request object containing the ID of the ").concat(args[0]," to update in URL parameters and the updated data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const update").concat(o," = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to update the ").concat(args[0]," by ID and get the result\n  const result = await ").concat(n,"Services.update").concat(o,"(id, req.body);\n  // Send a success response with the updated resource data\n  ServerResponse(res, true, 200, '").concat(o," updated successfully', result);\n});\n\n/**\n * Controller function to handle the update operation for multiple ").concat(args[0],".\n *\n * @param {Request} req - The request object containing an array of ").concat(args[0]," data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const updateMany").concat(o," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to update multiple ").concat(args[0]," and get the result\n  const result = await ").concat(n,"Services.updateMany").concat(o,"(req.body);\n  // Send a success response with the updated resources data\n  ServerResponse(res, true, 200, 'Resources updated successfully', result);\n});\n\n/**\n * Controller function to handle the deletion of a single ").concat(args[0],".\n *\n * @param {Request} req - The request object containing the ID of the ").concat(args[0]," to delete in URL parameters.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const delete").concat(o," = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to delete the ").concat(args[0]," by ID\n  await ").concat(n,"Services.delete").concat(o,"(id);\n  // Send a success response confirming the deletion\n  ServerResponse(res, true, 200, '").concat(o," deleted successfully');\n});\n\n/**\n * Controller function to handle the deletion of multiple ").concat(args[0],".\n *\n * @param {Request} req - The request object containing an array of IDs of ").concat(args[0]," to delete in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const deleteMany").concat(o," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to delete multiple ").concat(args[0]," and get the result\n  await ").concat(n,"Services.deleteMany").concat(o,"(req.body);\n  // Send a success response confirming the deletions\n  ServerResponse(res, true, 200, 'Resources deleted successfully');\n});\n\n/**\n * Controller function to handle the retrieval of a single ").concat(args[0]," by ID.\n *\n * @param {Request} req - The request object containing the ID of the ").concat(args[0]," to retrieve in URL parameters.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const get").concat(o,"ById = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to get the ").concat(args[0]," by ID and get the result\n  const result = await ").concat(n,"Services.get").concat(o,"ById(id);\n  // Send a success response with the retrieved resource data\n  ServerResponse(res, true, 200, '").concat(o," retrieved successfully', result);\n});\n\n/**\n * Controller function to handle the retrieval of multiple ").concat(args[0],".\n *\n * @param {Request} req - The request object containing query parameters for filtering.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const getMany").concat(o," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to get multiple ").concat(args[0]," based on query parameters and get the result\n  const result = await ").concat(n,"Services.getMany").concat(o,"(req.query);\n  // Send a success response with the retrieved resources data\n  ServerResponse(res, true, 200, 'Resources retrieved successfully', result);\n});\n    "),y=path.join(i,"".concat(args[0],".controller.ts"));fs.writeFileSync(y,f.trim());var g="\nimport mongoose, { Document, Schema } from 'mongoose';\n\n// Define and export an interface representing a ".concat(o," document\nexport interface I").concat(o," extends Document {\n  // Define the schema fields with their types\n  // Example fields (replace with actual fields)\n  // fieldName: fieldType;\n}\n\n// Define the ").concat(o," schema\nconst ").concat(o,"Schema: Schema<I").concat(o,"> = new Schema({\n  // Define schema fields here\n  // Example fields (replace with actual schema)\n  // fieldName: {\n  //   type: Schema.Types.FieldType,\n  //   required: true,\n  //   trim: true,\n  // },\n},{\n timestamps: true,\n versionKey: false,\n});\n\n// Create the ").concat(o," model\nconst ").concat(o," = mongoose.model<I").concat(o,">('").concat(o,"', ").concat(o,"Schema);\n\n// Export the ").concat(o," model\nexport default ").concat(o,";\n    "),s=path.join(l,"".concat(args[0],".model.ts"));c.exists||fs.writeFileSync(s,g.trim());i="\n/**\n * Type definition for ".concat(o,".\n *\n * This type defines the structure of a single ").concat(n," object.\n * @interface T").concat(o,"\n */\nexport interface T").concat(o," {\n  // Add fields as needed\n}\n    "),l=path.join(d,"".concat(args[0],".interface.ts"));fs.writeFileSync(l,i.trim());d="\nimport { NextFunction, Request, Response } from 'express';\nimport { z } from 'zod';\nimport zodErrorHandler from '../../handlers/zod-error-handler';\n\n/**\n * Zod schema for validating ".concat(n," data.\n */\nconst zod").concat(o,"Schema = z.object({\n // Define schema fields here\n}).strict();\n\n/**\n * Middleware function to validate ").concat(n," using Zod schema.\n * @param {object} req - The request object.\n * @param {object} res - The response object.\n * @param {function} next - The next middleware function.\n * @returns {void}\n */\nexport const validate").concat(o," = (req: Request, res: Response, next: NextFunction) => {\n  // Validate request body\n  const { error, success } = zod").concat(o,"Schema.safeParse(req.body);\n\n  // Check if validation was successful\n  if (!success) {\n    // If validation failed, use the Zod error handler to send an error response\n    return zodErrorHandler(req, res, error);\n  }\n\n  // If validation passed, proceed to the next middleware function\n  return next();\n};\n    "),u=path.join(u,"".concat(args[0],".validation.ts"));fs.writeFileSync(u,d.trim());var v=null==c||null===(v=c.filePath)||void 0===v?void 0:v.substring(c.filePath.indexOf("modules")+"modules".length+1),o="\n// Import the model\nimport ".concat(o,"Model, { I").concat(o," } from '").concat(c.exists?"../".concat(v.replace(/\\/g,"/").replace(/\.ts$/,"")):"./".concat(args[0],".model"),"';\n\n/**\n * Service function to create a new ").concat(n,".\n *\n * @param {Partial<I").concat(o,">} data - The data to create a new ").concat(n,".\n * @returns {Promise<Partial<I").concat(o,">>} - The created ").concat(n,".\n * @throws {Error} - Throws an error if the ").concat(n," creation fails.\n */\nconst create").concat(o," = async (data: Partial<I").concat(o,">): Promise<Partial<I").concat(o,">> => {\n  const new").concat(o," = new ").concat(o,"Model(data);\n  const saved").concat(o," = await new").concat(o,".save();\n  if (!saved").concat(o,") throw new Error('Failed to create ").concat(n,"');\n  return saved").concat(o,";\n};\n\n/**\n * Service function to create multiple ").concat(n,".\n *\n * @param {Partial<I").concat(o,">[]} data - An array of data to create multiple ").concat(n,".\n * @returns {Promise<Partial<I").concat(o,">[]>} - The created ").concat(n,".\n * @throws {Error} - Throws an error if the ").concat(n," creation fails.\n */\nconst createMany").concat(o," = async (data: Partial<I").concat(o,">[]): Promise<Partial<I").concat(o,">[]> => {\n  const created").concat(o," = await ").concat(o,"Model.insertMany(data);\n  if (!created").concat(o,") throw new Error('Failed to create multiple ").concat(n,"');\n  return created").concat(o,";\n};\n\n/**\n * Service function to update a single ").concat(n," by ID.\n *\n * @param {string} id - The ID of the ").concat(n," to update.\n * @param {Partial<I").concat(o,">} data - The updated data for the ").concat(n,".\n * @returns {Promise<Partial<I").concat(o,">>} - The updated ").concat(n,".\n * @throws {Error} - Throws an error if the ").concat(n," update fails.\n */\nconst update").concat(o," = async (id: string, data: Partial<I").concat(o,">): Promise<Partial<I").concat(o,">> => {\n  const updated").concat(o," = await ").concat(o,"Model.findByIdAndUpdate(id, data, { new: true });\n  if (!updated").concat(o,") throw new Error('Failed to update ").concat(n,"');\n  return updated").concat(o,";\n};\n\n/**\n * Service function to update multiple ").concat(n,".\n *\n * @param {Array<{ id: string, updates: Partial<I").concat(o,"> }>} data - An array of data to update multiple ").concat(n,".\n * @returns {Promise<Partial<I").concat(o,">[]>} - The updated ").concat(n,".\n * @throws {Error} - Throws an error if the ").concat(n," update fails.\n */\nconst updateMany").concat(o," = async (data: Array<{ id: string, updates: Partial<I").concat(o,"> }>): Promise<Partial<I").concat(o,">[]> => {\n  const updatePromises = data.map(({ id, updates }) =>\n    ").concat(o,"Model.findByIdAndUpdate(id, updates, { new: true })\n  );\n  const updated").concat(o," = await Promise.all(updatePromises);\n  \n  // Filter out null values\n  const validUpdated").concat(o," = updated").concat(o,".filter(item => item !== null) as I").concat(o,"[];\n\n  if (!validUpdated").concat(o,".length) throw new Error('Failed to update multiple ").concat(n,"');\n  return validUpdated").concat(o,";\n};\n\n/**\n * Service function to delete a single ").concat(n," by ID.\n *\n * @param {string} id - The ID of the ").concat(n," to delete.\n * @returns {Promise<Partial<I").concat(o,">>} - The deleted ").concat(n,".\n * @throws {Error} - Throws an error if the ").concat(n," deletion fails.\n */\nconst delete").concat(o," = async (id: string): Promise<Partial<I").concat(o,">> => {\n  const deleted").concat(o," = await ").concat(o,"Model.findByIdAndDelete(id);\n  if (!deleted").concat(o,") throw new Error('Failed to delete ").concat(n,"');\n  return deleted").concat(o,";\n};\n\n/**\n * Service function to delete multiple ").concat(n,".\n *\n * @param {string[]} ids - An array of IDs of ").concat(n," to delete.\n * @returns {Promise<Partial<I").concat(o,">[]>} - The deleted ").concat(n,".\n * @throws {Error} - Throws an error if the ").concat(n," deletion fails.\n */\nconst deleteMany").concat(o," = async (ids: string[]): Promise<Partial<I").concat(o,">[]> => {\n  const ").concat(n,"ToDelete = await ").concat(o,"Model.find({ _id: { $in: ids } });\n  if (!").concat(n,"ToDelete.length) throw new Error('No ").concat(n," found to delete');\n\n  const deleteResult = await ").concat(o,"Model.deleteMany({ _id: { $in: ids } });\n  if (deleteResult.deletedCount === 0) throw new Error('Failed to delete multiple ").concat(n,"');\n  \n  return ").concat(n,"ToDelete;  // Return the documents that were deleted\n};\n\n/**\n * Service function to retrieve a single ").concat(n," by ID.\n *\n * @param {string} id - The ID of the ").concat(n," to retrieve.\n * @returns {Promise<Partial<I").concat(o,">>} - The retrieved ").concat(n,".\n * @throws {Error} - Throws an error if the ").concat(n," retrieval fails.\n */\nconst get").concat(o,"ById = async (id: string): Promise<Partial<I").concat(o,">> => {\n  const ").concat(n," = await ").concat(o,"Model.findById(id);\n  if (!").concat(n,") throw new Error('").concat(n," not found');\n  return ").concat(n,";\n};\n\n/**\n * Service function to retrieve multiple ").concat(n," based on query parameters.\n *\n * @param {object} query - The query parameters for filtering ").concat(n,".\n * @returns {Promise<Partial<I").concat(o,">[]>} - The retrieved ").concat(n,".\n * @throws {Error} - Throws an error if the ").concat(n," retrieval fails.\n */\nconst getMany").concat(o," = async (query: object): Promise<Partial<I").concat(o,">[]> => {\n  const ").concat(n," = await ").concat(o,"Model.find(query);\n  if (!").concat(n,") throw new Error('Failed to retrieve ").concat(n,"');\n  return ").concat(n,";\n};\n\nexport const ").concat(n,"Services = {\n  create").concat(o,",\n  createMany").concat(o,",\n  update").concat(o,",\n  updateMany").concat(o,",\n  delete").concat(o,",\n  deleteMany").concat(o,",\n  get").concat(o,"ById,\n  getMany").concat(o,",\n};\n    "),p=path.join(p,"".concat(args[0],".service.ts"));fs.writeFileSync(p,o.trim()),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(t(y)," ").concat(BLUE,"(").concat(Buffer.byteLength(f,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(t(l)," ").concat(BLUE,"(").concat(Buffer.byteLength(i,"utf8")," bytes)")),c.exists||console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(t(s)," ").concat(BLUE,"(").concat(Buffer.byteLength(g,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(t(m)," ").concat(BLUE,"(").concat(Buffer.byteLength(h,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(t(p)," ").concat(BLUE,"(").concat(Buffer.byteLength(o,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(t(u)," ").concat(BLUE,"(").concat(Buffer.byteLength(d,"utf8")," bytes)"))}),program.parse(process.argv)):"nested-resource"===command?(program.version("1.0.0").description("Generate nested route, model, controller, and interface files for a new resource").argument("<path>","Nested path to resource (e.g., folder1/folder2/resourceName)").action(function(e){var n=args[0].split("/"),t=n[n.length-1],r="".concat(t,".model.ts");function a(e){return path.relative(path.join(__dirname,".."),e)}var c,o=(process.argv.slice(2),(c=function e(n){var t=_createForOfIteratorHelper(fs.readdirSync(n));try{for(t.s();!(o=t.n()).done;){var a=o.value,c=path.join(n,a);if(fs.statSync(c).isDirectory()){var o=e(c);if(o)return o}else if(a===r)return c}}catch(e){t.e(e)}finally{t.f()}return null}(path.join(process.cwd(),"src")))?{exists:!0,filePath:c}:{exists:!1,filePath:null}),s=n.pop(),i=specialCharRegex.test(args[0])?toCamelCase(s):s.toLowerCase(),d=n,l=capitalize(i),u=path.join(__dirname,"..","src"),p=path.join.apply(path,[u,"modules"].concat(_toConsumableArray(d),[s]));fs.existsSync(p)||fs.mkdirSync(p,{recursive:!0});var h="\n// Import Router from express\nimport { Router } from 'express';\n\n// Import controller from corresponding module\nimport { \n  create".concat(l,",\n  createMany").concat(l,",\n  update").concat(l,",\n  updateMany").concat(l,",\n  delete").concat(l,",\n  deleteMany").concat(l,",\n  get").concat(l,"ById,\n  getMany").concat(l,"\n} from './").concat(s,".controller';\n\n//Import validation from corresponding module\nimport { validate").concat(l," } from './").concat(s,".validation';\nimport { validateId, validateIds } from '").concat(Array(d.length+2).fill("..").join("/"),"/handlers/common-zod-validator';\n      \n// Initialize router\nconst router = Router();\n\n// Define route handlers\n/**\n * @route POST /api/v1/").concat(d.join("/"),"/").concat(s,"/create-").concat(s,"\n * @description Create a new ").concat(s,"\n * @access Public\n * @param {function} controller - ['create").concat(l,"']\n * @param {function} validation - ['validate").concat(l,"']\n */\nrouter.post(\"/create-").concat(s,'", validate').concat(l,", create").concat(l,");\n\n/**\n * @route POST /api/v1/").concat(d.join("/"),"/").concat(s,"/create-").concat(s,"/many\n * @description Create multiple ").concat(s,"\n * @access Public\n * @param {function} controller - ['createMany").concat(l,"']\n */\nrouter.post(\"/create-").concat(s,'/many", createMany').concat(l,");\n\n/**\n * @route PUT /api/v1/").concat(d.join("/"),"/").concat(s,"/update-").concat(s,"/many\n * @description Update multiple ").concat(s," information\n * @access Public\n * @param {function} controller - ['updateMany").concat(l,"']\n * @param {function} validation - ['validateIds']\n */\nrouter.put(\"/update-").concat(s,'/many", validateIds, updateMany').concat(l,");\n\n/**\n * @route PUT /api/v1/").concat(d.join("/"),"/").concat(s,"/update-").concat(s,"/:id\n * @description Update ").concat(s," information\n * @param {string} id - The ID of the ").concat(s," to update\n * @access Public\n * @param {function} controller - ['update").concat(l,"']\n * @param {function} validation - ['validateId', 'validate").concat(l,"']\n */\nrouter.put(\"/update-").concat(s,'/:id", validateId, validate').concat(l,", update").concat(l,");\n\n/**\n * @route DELETE /api/v1/").concat(d.join("/"),"/").concat(s,"/delete-").concat(s,"/many\n * @description Delete multiple ").concat(s,"\n * @access Public\n * @param {function} controller - ['deleteMany").concat(l,"']\n * @param {function} validation - ['validateIds']\n */\nrouter.delete(\"/delete-").concat(s,'/many", validateIds, deleteMany').concat(l,");\n\n/**\n * @route DELETE /api/v1/").concat(d.join("/"),"/").concat(s,"/delete-").concat(s,"/:id\n * @description Delete a ").concat(s,"\n * @param {string} id - The ID of the ").concat(s," to delete\n * @access Public\n * @param {function} controller - ['delete").concat(l,"']\n * @param {function} validation - ['validateId']\n */\nrouter.delete(\"/delete-").concat(s,'/:id", validateId, delete').concat(l,");\n\n/**\n * @route GET /api/v1/").concat(d.join("/"),"/").concat(s,"/get-").concat(s,"/many\n * @description Get multiple ").concat(s,"\n * @access Public\n * @param {function} controller - ['getMany").concat(l,"']\n * @param {function} validation - ['validateIds']\n */\nrouter.get(\"/get-").concat(s,'/many", validateIds, getMany').concat(l,");\n\n/**\n * @route GET /api/v1/").concat(d.join("/"),"/").concat(s,"/get-").concat(s,"/:id\n * @description Get a ").concat(s," by ID\n * @param {string} id - The ID of the ").concat(s," to retrieve\n * @access Public\n * @param {function} controller - ['get").concat(l,"ById']\n * @param {function} validation - ['validateId']\n */\nrouter.get(\"/get-").concat(s,'/:id", validateId, get').concat(l,"ById);\n\n// Export the router\nmodule.exports = router;\n    "),m=path.join(p,"".concat(s,".route.ts"));fs.writeFileSync(m,h.trim());var f="\nimport { Request, Response } from 'express';\nimport { ".concat(i,"Services } from './").concat(s,".service';\nimport ServerResponse from '").concat(Array(d.length+2).fill("..").join("/"),"/helpers/responses/custom-response';\nimport catchAsync from '").concat(Array(d.length+2).fill("..").join("/"),"/utils/catch-async/catch-async';\n\n/**\n * Controller function to handle the creation of a single ").concat(l,".\n *\n * @param {Request} req - The request object containing ").concat(s," data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const create").concat(l," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to create a new ").concat(s," and get the result\n  const result = await ").concat(i,"Services.create").concat(l,"(req.body);\n  // Send a success response with the created resource data\n  ServerResponse(res, true, 201, '").concat(l," created successfully', result);\n});\n\n/**\n * Controller function to handle the creation of multiple ").concat(s,".\n *\n * @param {Request} req - The request object containing an array of ").concat(s," data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const createMany").concat(l," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to create multiple ").concat(s," and get the result\n  const result = await ").concat(i,"Services.createMany").concat(l,"(req.body);\n  // Send a success response with the created resources data\n  ServerResponse(res, true, 201, 'Resources created successfully', result);\n});\n\n/**\n * Controller function to handle the update operation for a single ").concat(l,".\n *\n * @param {Request} req - The request object containing the ID of the ").concat(s," to update in URL parameters and the updated data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const update").concat(l," = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to update the ").concat(s," by ID and get the result\n  const result = await ").concat(i,"Services.update").concat(l,"(id, req.body);\n  // Send a success response with the updated resource data\n  ServerResponse(res, true, 200, '").concat(l," updated successfully', result);\n});\n\n/**\n * Controller function to handle the update operation for multiple ").concat(s,".\n *\n * @param {Request} req - The request object containing an array of ").concat(s," data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const updateMany").concat(l," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to update multiple ").concat(s," and get the result\n  const result = await ").concat(i,"Services.updateMany").concat(l,"(req.body);\n  // Send a success response with the updated resources data\n  ServerResponse(res, true, 200, 'Resources updated successfully', result);\n});\n\n/**\n * Controller function to handle the deletion of a single ").concat(l,".\n *\n * @param {Request} req - The request object containing the ID of the ").concat(s," to delete in URL parameters.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const delete").concat(l," = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to delete the ").concat(s," by ID\n  await ").concat(i,"Services.delete").concat(l,"(id);\n  // Send a success response confirming the deletion\n  ServerResponse(res, true, 200, '").concat(l," deleted successfully');\n});\n\n/**\n * Controller function to handle the deletion of multiple ").concat(s,".\n *\n * @param {Request} req - The request object containing an array of IDs of ").concat(s," to delete in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const deleteMany").concat(l," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to delete multiple ").concat(s," and get the result\n  await ").concat(i,"Services.deleteMany").concat(l,"(req.body);\n  // Send a success response confirming the deletions\n  ServerResponse(res, true, 200, 'Resources deleted successfully');\n});\n\n/**\n * Controller function to handle the retrieval of a single ").concat(l," by ID.\n *\n * @param {Request} req - The request object containing the ID of the ").concat(s," to retrieve in URL parameters.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const get").concat(l,"ById = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to get the ").concat(s," by ID and get the result\n  const result = await ").concat(i,"Services.get").concat(l,"ById(id);\n  // Send a success response with the retrieved resource data\n  ServerResponse(res, true, 200, '").concat(l," retrieved successfully', result);\n});\n\n/**\n * Controller function to handle the retrieval of multiple ").concat(s,".\n *\n * @param {Request} req - The request object containing query parameters for filtering.\n * @param {Response} res - The response object used to send the response.\n * @returns {void}\n */\nexport const getMany").concat(l," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to get multiple ").concat(s," based on query parameters and get the result\n  const result = await ").concat(i,"Services.getMany").concat(l,"(req.query);\n  // Send a success response with the retrieved resources data\n  ServerResponse(res, true, 200, 'Resources retrieved successfully', result);\n});\n    "),y=path.join(p,"".concat(s,".controller.ts"));fs.writeFileSync(y,f.trim());var g="\nimport mongoose, { Document, Schema } from 'mongoose';\n\n// Define and export an interface representing a ".concat(l," document\nexport interface I").concat(l," extends Document {\n  // Define the schema fields with their types\n  // Example fields (replace with actual fields)\n  // fieldName: fieldType;\n}\n\nconst ").concat(l,"Schema: Schema<I").concat(l,"> = new Schema({\n  // Define schema fields here\n  // Example fields (replace with actual schema)\n  // fieldName: {\n  //   type: Schema.Types.FieldType,\n  //   required: true,\n  //   trim: true,\n  // },\n},{\n timestamps: true,\n versionKey: false,\n});\n\nconst ").concat(l," = mongoose.model<I").concat(l,">('").concat(l,"', ").concat(l,"Schema);\n\nexport default ").concat(l,";\n    "),v=path.join(p,"".concat(s,".model.ts"));o.exists||fs.writeFileSync(v,g.trim());t="\nexport interface T".concat(l," {\n  // Add fields as needed\n}\n    "),n=path.join(p,"".concat(s,".interface.ts"));fs.writeFileSync(n,t.trim());u="\nimport { NextFunction, Request, Response } from 'express';\nimport { z } from 'zod';\nimport zodErrorHandler from '".concat(Array(d.length+2).fill("..").join("/"),"/handlers/zod-error-handler';\n\n/**\n * Zod schema for validating ").concat(s," data.\n */\nconst zod").concat(l,"Schema = z.object({\n  // Define schema fields here\n}).strict();\n\n/**\n * Middleware function to validate ").concat(s," using Zod schema.\n * @param {object} req - The request object.\n * @param {object} res - The response object.\n * @param {function} next - The next middleware function.\n * @returns {void}\n */\nexport const validate").concat(l," = (req: Request, res: Response, next: NextFunction) => {\n  // Validate request body\n  const { error, success } = zod").concat(l,"Schema.safeParse(req.body);\n\n  // Check if validation was successful\n  if (!success) {\n    // If validation failed, use the Zod error handler to send an error response\n    return zodErrorHandler(req, res, error);\n  }\n\n  // If validation passed, proceed to the next middleware function\n  return next();\n};\n\n"),i=path.join(p,"".concat(s,".validation.ts"));fs.writeFileSync(i,u.trim());l="\n// Import the model\nimport ".concat(l,"Model, { I").concat(l," } from '").concat((o.exists?"".concat(Array(d.length+1).fill("..").join("/"),"/").concat(s,"/"):"./").concat(s,".model"),"';\n\n/**\n * Service function to create a new ").concat(s,".\n *\n * @param {Partial<I").concat(l,">} data - The data to create a new ").concat(s,".\n * @returns {Promise<Partial<I").concat(l,">>} - The created ").concat(s,".\n * @throws {Error} - Throws an error if the ").concat(s," creation fails.\n */\nconst create").concat(l," = async (data: Partial<I").concat(l,">): Promise<Partial<I").concat(l,">> => {\n  const new").concat(l," = new ").concat(l,"Model(data);\n  const saved").concat(l," = await new").concat(l,".save();\n  if (!saved").concat(l,") throw new Error('Failed to create ").concat(s,"');\n  return saved").concat(l,";\n};\n\n/**\n * Service function to create multiple ").concat(s,".\n *\n * @param {Partial<I").concat(l,">[]} data - An array of data to create multiple ").concat(s,".\n * @returns {Promise<Partial<I").concat(l,">[]>} - The created ").concat(s,".\n * @throws {Error} - Throws an error if the ").concat(s," creation fails.\n */\nconst createMany").concat(l," = async (data: Partial<I").concat(l,">[]): Promise<Partial<I").concat(l,">[]> => {\n  const created").concat(l," = await ").concat(l,"Model.insertMany(data);\n  if (!created").concat(l,") throw new Error('Failed to create multiple ").concat(s,"');\n  return created").concat(l,";\n};\n\n/**\n * Service function to update a single ").concat(s," by ID.\n *\n * @param {string} id - The ID of the ").concat(s," to update.\n * @param {Partial<I").concat(l,">} data - The updated data for the ").concat(s,".\n * @returns {Promise<Partial<I").concat(l,">>} - The updated ").concat(s,".\n * @throws {Error} - Throws an error if the ").concat(s," update fails.\n */\nconst update").concat(l," = async (id: string, data: Partial<I").concat(l,">): Promise<Partial<I").concat(l,">> => {\n  const updated").concat(l," = await ").concat(l,"Model.findByIdAndUpdate(id, data, { new: true });\n  if (!updated").concat(l,") throw new Error('Failed to update ").concat(s,"');\n  return updated").concat(l,";\n};\n\n/**\n * Service function to update multiple ").concat(s,".\n *\n * @param {Array<{ id: string, updates: Partial<I").concat(l,"> }>} data - An array of data to update multiple ").concat(s,".\n * @returns {Promise<Partial<I").concat(l,">[]>} - The updated ").concat(s,".\n * @throws {Error} - Throws an error if the ").concat(s," update fails.\n */\nconst updateMany").concat(l," = async (data: Array<{ id: string, updates: Partial<I").concat(l,"> }>): Promise<Partial<I").concat(l,">[]> => {\n  const updatePromises = data.map(({ id, updates }) =>\n    ").concat(l,"Model.findByIdAndUpdate(id, updates, { new: true })\n  );\n  const updated").concat(l," = await Promise.all(updatePromises);\n  \n  // Filter out null values\n  const validUpdated").concat(l," = updated").concat(l,".filter(item => item !== null) as I").concat(l,"[];\n\n  if (!validUpdated").concat(l,".length) throw new Error('Failed to update multiple ").concat(s,"');\n  return validUpdated").concat(l,";\n};\n\n/**\n * Service function to delete a single ").concat(s," by ID.\n *\n * @param {string} id - The ID of the ").concat(s," to delete.\n * @returns {Promise<Partial<I").concat(l,">>} - The deleted ").concat(s,".\n * @throws {Error} - Throws an error if the ").concat(s," deletion fails.\n */\nconst delete").concat(l," = async (id: string): Promise<Partial<I").concat(l,">> => {\n  const deleted").concat(l," = await ").concat(l,"Model.findByIdAndDelete(id);\n  if (!deleted").concat(l,") throw new Error('Failed to delete ").concat(s,"');\n  return deleted").concat(l,";\n};\n\n/**\n * Service function to delete multiple ").concat(s,".\n *\n * @param {string[]} ids - An array of IDs of ").concat(s," to delete.\n * @returns {Promise<Partial<I").concat(l,">[]>} - The deleted ").concat(s,".\n * @throws {Error} - Throws an error if the ").concat(s," deletion fails.\n */\nconst deleteMany").concat(l," = async (ids: string[]): Promise<Partial<I").concat(l,">[]> => {\n  const ").concat(s,"ToDelete = await ").concat(l,"Model.find({ _id: { $in: ids } });\n  if (!").concat(s,"ToDelete.length) throw new Error('No ").concat(s," found to delete');\n\n  const deleteResult = await ").concat(l,"Model.deleteMany({ _id: { $in: ids } });\n  if (deleteResult.deletedCount === 0) throw new Error('Failed to delete multiple ").concat(s,"');\n  \n  return ").concat(s,"ToDelete;  // Return the documents that were deleted\n};\n\n/**\n * Service function to retrieve a single ").concat(s," by ID.\n *\n * @param {string} id - The ID of the ").concat(s," to retrieve.\n * @returns {Promise<Partial<I").concat(l,">>} - The retrieved ").concat(s,".\n * @throws {Error} - Throws an error if the ").concat(s," retrieval fails.\n */\nconst get").concat(l,"ById = async (id: string): Promise<Partial<I").concat(l,">> => {\n  const ").concat(s," = await ").concat(l,"Model.findById(id);\n  if (!").concat(s,") throw new Error('").concat(s," not found');\n  return ").concat(s,";\n};\n\n/**\n * Service function to retrieve multiple ").concat(s," based on query parameters.\n *\n * @param {object} query - The query parameters for filtering ").concat(s,".\n * @returns {Promise<Partial<I").concat(l,">[]>} - The retrieved ").concat(s,".\n * @throws {Error} - Throws an error if the ").concat(s," retrieval fails.\n */\nconst getMany").concat(l," = async (query: object): Promise<Partial<I").concat(l,">[]> => {\n  const ").concat(s," = await ").concat(l,"Model.find(query);\n  if (!").concat(s,") throw new Error('Failed to retrieve ").concat(s,"');\n  return ").concat(s,";\n};\n\nexport const ").concat(s,"Services = {\n  create").concat(l,",\n  createMany").concat(l,",\n  update").concat(l,",\n  updateMany").concat(l,",\n  delete").concat(l,",\n  deleteMany").concat(l,",\n  get").concat(l,"ById,\n  getMany").concat(l,",\n};\n    "),s=path.join(p,"".concat(s,".service.ts"));fs.writeFileSync(s,l.trim()),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(a(y)," ").concat(BLUE,"(").concat(Buffer.byteLength(f,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(a(n)," ").concat(BLUE,"(").concat(Buffer.byteLength(t,"utf8")," bytes)")),o.exists||(fs.writeFileSync(v,g.trim()),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(a(v)," ").concat(BLUE,"(").concat(Buffer.byteLength(g,"utf8")," bytes)"))),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(a(m)," ").concat(BLUE,"(").concat(Buffer.byteLength(h,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(a(s)," ").concat(BLUE,"(").concat(Buffer.byteLength(l,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(a(i)," ").concat(BLUE,"(").concat(Buffer.byteLength(u,"utf8")," bytes)"))}),program.parse(process.argv)):(console.error("Unknown command: ".concat(command)),process.exit(1));