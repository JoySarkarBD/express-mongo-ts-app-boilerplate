#!/usr/bin/env node
function _createForOfIteratorHelper(e,n){var t="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(!t){if(Array.isArray(e)||(t=_unsupportedIterableToArray(e))||n&&e&&"number"==typeof e.length){t&&(e=t);var a=0,r=function e(){};return{s:r,n:function n(){return a>=e.length?{done:!0}:{done:!1,value:e[a++]}},e:function e(n){throw n},f:r}}throw TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var c,o=!0,s=!1;return{s:function n(){t=t.call(e)},n:function e(){var n=t.next();return o=n.done,n},e:function e(n){s=!0,c=n},f:function e(){try{o||null==t.return||t.return()}finally{if(s)throw c}}}}function _toArray(e){return _arrayWithHoles(e)||_iterableToArray(e)||_unsupportedIterableToArray(e)||_nonIterableRest()}function _nonIterableRest(){throw TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _unsupportedIterableToArray(e,n){if(e){if("string"==typeof e)return _arrayLikeToArray(e,n);var t=({}).toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?_arrayLikeToArray(e,n):void 0}}function _arrayLikeToArray(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=Array(n);t<n;t++)a[t]=e[t];return a}function _iterableToArray(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}function _arrayWithHoles(e){if(Array.isArray(e))return e}var _process$argv=_toArray(process.argv),command=_process$argv[2],args=_process$argv.slice(3),fs=require("fs"),path=require("path"),_require=require("commander"),program=_require.program,GREEN="\x1b[32m",BLUE="\x1b[34m",RESET="\x1b[0m",specialCharRegex=/[0-9!@#$%^&*()_+{}\[\]:;"'<>,.?/~`|\-=\s]/g;function capitalize(e){return e.charAt(0).toUpperCase()+e.slice(1)}function toCamelCase(e){return e.replace(/[^a-zA-Z]+/g,"-").replace(/^-+|-+$/g,"").split("-").map(function(e,n){return 0===n?e.toLowerCase():e.charAt(0).toUpperCase()+e.slice(1).toLowerCase()}).join("")}"resource"===command?(program.version("1.0.0").description("Generate route, model, controller, and interface files for a new resource").argument("<name>","Resource name").action(function(e){var n,t=specialCharRegex.test(args[0])?toCamelCase(args[0]):args[0].toLowerCase(),a=capitalize(t);n=args[0],function e(t){var r,c=fs.readdirSync(t),o=_createForOfIteratorHelper(c);try{for(o.s();!(r=o.n()).done;)r.value===n&&(console.log("".concat(GREEN).concat(a," ").concat(RESET,"module already exists.")),process.exit(0))}catch(s){o.e(s)}finally{o.f()}return!1}(path.join(process.cwd(),"src","modules"));var r=path.join(__dirname,"..","src","modules",args[0]),c=path.join(__dirname,"..","src","modules",args[0]),o=path.join(__dirname,"..","src","modules",args[0]),s=path.join(__dirname,"..","src","modules",args[0]),i=path.join(__dirname,"..","src","modules",args[0]),d=path.join(__dirname,"..","src","modules",args[0]),l=function e(n){return path.relative(path.join(__dirname,".."),n)};[r,c,s,o].forEach(function(e){fs.existsSync(e)||fs.mkdirSync(e,{recursive:!0})});var u="\n// Import Router from express\nimport { Router } from 'express';\n\n// Import controller from corresponding module\nimport { \n  create".concat(a,",\n  createMany").concat(a,",\n  update").concat(a,",\n  updateMany").concat(a,",\n  delete").concat(a,",\n  deleteMany").concat(a,",\n  get").concat(a,"ById,\n  getMany").concat(a,"\n} from './").concat(args[0],".controller';\n\n//Import validation from corresponding module\nimport { validate").concat(a," } from './").concat(args[0],".validation';\nimport { validateId, validateIds } from '../../handlers/common-zod-validator';\n\n// Initialize router\nconst router = Router();\n\n// Define route handlers\n/**\n * @route POST /api/v1/").concat(args[0],"/create-").concat(args[0],"\n * @description Create a new ").concat(args[0],"\n * @access Public\n * @param {function} controller - ['create").concat(a,"']\n * @param {function} validation - ['validate").concat(a,"']\n */\nrouter.post(\"/create-").concat(args[0],'", validate').concat(a,", create").concat(a,");\n\n/**\n * @route POST /api/v1/").concat(args[0],"/create-").concat(args[0],"/many\n * @description Create multiple ").concat(args[0],"\n * @access Public\n * @param {function} controller - ['createMany").concat(a,"']\n */\nrouter.post(\"/create-").concat(args[0],'/many", createMany').concat(a,");\n\n/**\n * @route PUT /api/v1/").concat(args[0],"/update-").concat(args[0],"/many\n * @description Update multiple ").concat(args[0]," information\n * @access Public\n * @param {function} controller - ['updateMany").concat(a,"']\n * @param {function} validation - ['validateIds']\n */\nrouter.put(\"/update-").concat(args[0],'/many", validateIds, updateMany').concat(a,");\n\n/**\n * @route PUT /api/v1/").concat(args[0],"/update-").concat(args[0],"/:id\n * @description Update ").concat(args[0]," information\n * @param {string} id - The ID of the ").concat(args[0]," to update\n * @access Public\n * @param {function} controller - ['update").concat(a,"']\n * @param {function} validation - ['validateId', 'validate").concat(a,"']\n */\nrouter.put(\"/update-").concat(args[0],'/:id", validateId, validate').concat(a,", update").concat(a,");\n\n/**\n * @route DELETE /api/v1/").concat(args[0],"/delete-").concat(args[0],"/many\n * @description Delete multiple ").concat(args[0],"\n * @access Public\n * @param {function} controller - ['deleteMany").concat(a,"']\n * @param {function} validation - ['validateIds']\n */\nrouter.delete(\"/delete-").concat(args[0],'/many", validateIds, deleteMany').concat(a,");\n\n/**\n * @route DELETE /api/v1/").concat(args[0],"/delete-").concat(args[0],"/:id\n * @description Delete a ").concat(args[0],"\n * @param {string} id - The ID of the ").concat(args[0]," to delete\n * @access Public\n * @param {function} controller - ['delete").concat(a,"']\n * @param {function} validation - ['validateId']\n */\nrouter.delete(\"/delete-").concat(args[0],'/:id", validateId, delete').concat(a,");\n\n/**\n * @route GET /api/v1/").concat(args[0],"/get-").concat(args[0],"/many\n * @description Get multiple ").concat(args[0],"\n * @access Public\n * @param {function} controller - ['getMany").concat(a,"']\n * @param {function} validation - ['validateIds']\n */\nrouter.get(\"/get-").concat(args[0],'/many", validateIds, getMany').concat(a,");\n\n/**\n * @route GET /api/v1/").concat(args[0],"/get-").concat(args[0],"/:id\n * @description Get a ").concat(args[0]," by ID\n * @param {string} id - The ID of the ").concat(args[0]," to retrieve\n * @access Public\n * @param {function} controller - ['get").concat(a,"ById']\n * @param {function} validation - ['validateId']\n */\nrouter.get(\"/get-").concat(args[0],'/:id", validateId, get').concat(a,"ById);\n\n// Export the router\nmodule.exports = router;\n    "),p=path.join(r,"".concat(args[0],".route.ts"));fs.writeFileSync(p,u.trim());var m="\nimport { Request, Response } from 'express';\nimport { ".concat(t,"Services } from './").concat(args[0],".service';\nimport ServerResponse from '../../helpers/responses/custom-response';\nimport catchAsync from '../../utils/catch-async/catch-async';\n\n/**\n * Controller function to handle the creation of a single ").concat(a,".\n *\n * @param {Request} req - The request object containing ").concat(args[0]," data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {Promise<Partial<I").concat(a,">>} - The created ").concat(t,".\n * @throws {Error} - Throws an error if the ").concat(t," creation fails.\n */\nexport const create").concat(a," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to create a new ").concat(args[0]," and get the result\n  const result = await ").concat(t,"Services.create").concat(a,"(req.body);\n  if (!result) throw new Error('Failed to create ").concat(t,"');\n  // Send a success response with the created resource data\n  ServerResponse(res, true, 201, '").concat(a," created successfully', result);\n});\n\n/**\n * Controller function to handle the creation of multiple ").concat(args[0],".\n *\n * @param {Request} req - The request object containing an array of ").concat(args[0]," data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {Promise<Partial<I").concat(a,">[]>} - The created ").concat(t,".\n * @throws {Error} - Throws an error if the ").concat(t," creation fails.\n */\nexport const createMany").concat(a," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to create multiple ").concat(t,"s and get the result\n  const result = await ").concat(t,"Services.createMany").concat(a,"(req.body);\n  if (!result) throw new Error('Failed to create multiple ").concat(t,"');\n  // Send a success response with the created resources data\n  ServerResponse(res, true, 201, '").concat(a,"s created successfully', result);\n});\n\n/**\n * Controller function to handle the update operation for a single ").concat(args[0],".\n *\n * @param {Request} req - The request object containing the ID of the ").concat(args[0]," to update in URL parameters and the updated data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {Promise<Partial<I").concat(a,">>} - The updated ").concat(t,".\n * @throws {Error} - Throws an error if the ").concat(t," update fails.\n */\nexport const update").concat(a," = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to update the ").concat(args[0]," by ID and get the result\n  const result = await ").concat(t,"Services.update").concat(a,"(id, req.body);\n  if (!result) throw new Error('Failed to update ").concat(t,"');\n  // Send a success response with the updated resource data\n  ServerResponse(res, true, 200, '").concat(a," updated successfully', result);\n});\n\n/**\n * Controller function to handle the update operation for multiple ").concat(args[0],".\n *\n * @param {Request} req - The request object containing an array of ").concat(args[0]," data in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {Promise<Partial<I").concat(a,">[]>} - The updated ").concat(t,".\n * @throws {Error} - Throws an error if the ").concat(t," update fails.\n */\nexport const updateMany").concat(a," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to update multiple ").concat(args[0]," and get the result\n  const result = await ").concat(t,"Services.updateMany").concat(a,"(req.body);\n  if (!result.length) throw new Error('Failed to update multiple ").concat(t,"');\n  // Send a success response with the updated resources data\n  ServerResponse(res, true, 200, '").concat(a,"s updated successfully', result);\n});\n\n/**\n * Controller function to handle the deletion of a single ").concat(args[0],".\n *\n * @param {Request} req - The request object containing the ID of the ").concat(args[0]," to delete in URL parameters.\n * @param {Response} res - The response object used to send the response.\n * @returns {Promise<Partial<I").concat(a,">>} - The deleted ").concat(t,".\n * @throws {Error} - Throws an error if the ").concat(t," deletion fails.\n */\nexport const delete").concat(a," = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to delete the ").concat(args[0]," by ID\n  const result = await ").concat(t,"Services.delete").concat(a,"(id);\n  if (!result) throw new Error('Failed to delete ").concat(t,"');\n  // Send a success response confirming the deletion\n  ServerResponse(res, true, 200, '").concat(a," deleted successfully');\n});\n\n/**\n * Controller function to handle the deletion of multiple ").concat(args[0],".\n *\n * @param {Request} req - The request object containing an array of IDs of ").concat(args[0]," to delete in the body.\n * @param {Response} res - The response object used to send the response.\n * @returns {Promise<Partial<I").concat(a,">[]>} - The deleted ").concat(t,".\n * @throws {Error} - Throws an error if the ").concat(t," deletion fails.\n */\nexport const deleteMany").concat(a," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to delete multiple ").concat(args[0]," and get the result\n  const result = await ").concat(t,"Services.deleteMany").concat(a,"(req.body);\n  if (!result) throw new Error('Failed to delete multiple ").concat(t,"');\n  // Send a success response confirming the deletions\n  ServerResponse(res, true, 200, '").concat(a,"s deleted successfully');\n});\n\n/**\n * Controller function to handle the retrieval of a single ").concat(args[0]," by ID.\n *\n * @param {Request} req - The request object containing the ID of the ").concat(args[0]," to retrieve in URL parameters.\n * @param {Response} res - The response object used to send the response.\n * @returns {Promise<Partial<I").concat(a,">>} - The retrieved ").concat(t,".\n * @throws {Error} - Throws an error if the ").concat(t," retrieval fails.\n */\nexport const get").concat(a,"ById = catchAsync(async (req: Request, res: Response) => {\n  const { id } = req.params;\n  // Call the service method to get the ").concat(args[0]," by ID and get the result\n  const result = await ").concat(t,"Services.get").concat(a,"ById(id);\n  if (!result) throw new Error('").concat(t," not found');\n  // Send a success response with the retrieved resource data\n  ServerResponse(res, true, 200, '").concat(a," retrieved successfully', result);\n});\n\n/**\n * Controller function to handle the retrieval of multiple ").concat(args[0],".\n *\n * @param {Request} req - The request object containing query parameters for filtering.\n * @param {Response} res - The response object used to send the response.\n * @returns {Promise<Partial<I").concat(a,">[]>} - The retrieved ").concat(t,".\n * @throws {Error} - Throws an error if the ").concat(t," retrieval fails.\n */\nexport const getMany").concat(a," = catchAsync(async (req: Request, res: Response) => {\n  // Call the service method to get multiple ").concat(args[0]," based on query parameters and get the result\n  const result = await ").concat(t,"Services.getMany").concat(a,"(req.query);\n  if (!result) throw new Error('Failed to retrieve ").concat(t,"');\n  // Send a success response with the retrieved resources data\n  ServerResponse(res, true, 200, '").concat(a,"s retrieved successfully', result);\n});\n    "),h=path.join(c,"".concat(args[0],".controller.ts"));fs.writeFileSync(h,m.trim());var f="\nimport mongoose, { Document, Schema } from 'mongoose';\n\n// Define and export an interface representing a ".concat(a," document\nexport interface I").concat(a," extends Document {\n  // Define the schema fields with their types\n  // Example fields (replace with actual fields)\n  // fieldName: fieldType;\n}\n\n// Define the ").concat(a," schema\nconst ").concat(a,"Schema: Schema<I").concat(a,"> = new Schema({\n  // Define schema fields here\n  // Example fields (replace with actual schema)\n  // fieldName: {\n  //   type: Schema.Types.FieldType,\n  //   required: true,\n  //   trim: true,\n  // },\n},{\n timestamps: true,\n versionKey: false,\n});\n\n// Create the ").concat(a," model\nconst ").concat(a," = mongoose.model<I").concat(a,">('").concat(a,"', ").concat(a,"Schema);\n\n// Export the ").concat(a," model\nexport default ").concat(a,";\n    "),g=path.join(s,"".concat(args[0],".model.ts"));fs.writeFileSync(g,f.trim());var y="\n/**\n * Type definition for ".concat(a,".\n *\n * This type defines the structure of a single ").concat(t," object.\n * @interface T").concat(a,"\n */\nexport interface T").concat(a," {\n  // Add fields as needed\n}\n    "),v=path.join(o,"".concat(args[0],".interface.ts"));fs.writeFileSync(v,y.trim());var $="\nimport { NextFunction, Request, Response } from 'express';\nimport { z } from 'zod';\nimport zodErrorHandler from '../../handlers/zod-error-handler';\n\n/**\n * Zod schema for validating ".concat(t," data.\n */\nconst zod").concat(a,"Schema = z.object({\n // Define schema fields here\n}).strict();\n\n/**\n * Middleware function to validate ").concat(t," using Zod schema.\n * @param {object} req - The request object.\n * @param {object} res - The response object.\n * @param {function} next - The next middleware function.\n * @returns {void}\n */\nexport const validate").concat(a," = (req: Request, res: Response, next: NextFunction) => {\n  // Validate request body\n  const { error, success } = zod").concat(a,"Schema.safeParse(req.body);\n\n  // Check if validation was successful\n  if (!success) {\n    // If validation failed, use the Zod error handler to send an error response\n    return zodErrorHandler(req, res, error);\n  }\n\n  // If validation passed, proceed to the next middleware function\n  return next();\n};\n    "),I=path.join(i,"".concat(args[0],".validation.ts"));fs.writeFileSync(I,$.trim());var T="\n// Import the model\nimport ".concat(a,"Model, { I").concat(a," } from './").concat(args[0],".model';\n\n/**\n * Service function to create a new ").concat(t,".\n *\n * @param {Partial<I").concat(a,">} data - The data to create a new ").concat(t,".\n * @returns {Promise<Partial<I").concat(a,">>} - The created ").concat(t,".\n */\nconst create").concat(a," = async (data: Partial<I").concat(a,">): Promise<Partial<I").concat(a,">> => {\n  const new").concat(a," = new ").concat(a,"Model(data);\n  const saved").concat(a," = await new").concat(a,".save();\n  return saved").concat(a,";\n};\n\n/**\n * Service function to create multiple ").concat(t,".\n *\n * @param {Partial<I").concat(a,">[]} data - An array of data to create multiple ").concat(t,".\n * @returns {Promise<Partial<I").concat(a,">[]>} - The created ").concat(t,".\n */\nconst createMany").concat(a," = async (data: Partial<I").concat(a,">[]): Promise<Partial<I").concat(a,">[]> => {\n  const created").concat(a," = await ").concat(a,"Model.insertMany(data);\n  return created").concat(a,";\n};\n\n/**\n * Service function to update a single ").concat(t," by ID.\n *\n * @param {string} id - The ID of the ").concat(t," to update.\n * @param {Partial<I").concat(a,">} data - The updated data for the ").concat(t,".\n * @returns {Promise<Partial<I").concat(a,">>} - The updated ").concat(t,".\n */\nconst update").concat(a," = async (id: string, data: Partial<I").concat(a,">): Promise<Partial<I").concat(a," | null>> => {\n  const updated").concat(a," = await ").concat(a,"Model.findByIdAndUpdate(id, data, { new: true });\n  return updated").concat(a,";\n};\n\n/**\n * Service function to update multiple ").concat(t,".\n *\n * @param {Array<{ id: string, updates: Partial<I").concat(a,"> }>} data - An array of data to update multiple ").concat(t,".\n * @returns {Promise<Partial<I").concat(a,">[]>} - The updated ").concat(t,".\n */\nconst updateMany").concat(a," = async (data: Array<{ id: string, updates: Partial<I").concat(a,"> }>): Promise<Partial<I").concat(a,">[]> => {\n  const updatePromises = data.map(({ id, updates }) =>\n    ").concat(a,"Model.findByIdAndUpdate(id, updates, { new: true })\n  );\n  const updated").concat(a," = await Promise.all(updatePromises);\n  // Filter out null values\n  const validUpdated").concat(a," = updated").concat(a,".filter(item => item !== null) as I").concat(a,"[];\n  return validUpdated").concat(a,";\n};\n\n/**\n * Service function to delete a single ").concat(t," by ID.\n *\n * @param {string} id - The ID of the ").concat(t," to delete.\n * @returns {Promise<Partial<I").concat(a,">>} - The deleted ").concat(t,".\n */\nconst delete").concat(a," = async (id: string): Promise<Partial<I").concat(a," | null>> => {\n  const deleted").concat(a," = await ").concat(a,"Model.findByIdAndDelete(id);\n  return deleted").concat(a,";\n};\n\n/**\n * Service function to delete multiple ").concat(t,".\n *\n * @param {string[]} ids - An array of IDs of ").concat(t," to delete.\n * @returns {Promise<Partial<I").concat(a,">[]>} - The deleted ").concat(t,".\n */\nconst deleteMany").concat(a," = async (ids: string[]): Promise<Partial<I").concat(a,">[]> => {\n  const ").concat(t,"ToDelete = await ").concat(a,"Model.find({ _id: { $in: ids } });\n  if (!").concat(t,"ToDelete.length) throw new Error('No ").concat(t," found to delete');\n  await ").concat(a,"Model.deleteMany({ _id: { $in: ids } });\n  return ").concat(t,"ToDelete; \n};\n\n/**\n * Service function to retrieve a single ").concat(t," by ID.\n *\n * @param {string} id - The ID of the ").concat(t," to retrieve.\n * @returns {Promise<Partial<I").concat(a,">>} - The retrieved ").concat(t,".\n */\nconst get").concat(a,"ById = async (id: string): Promise<Partial<I").concat(a," | null>> => {\n  const ").concat(t," = await ").concat(a,"Model.findById(id);\n  return ").concat(t,";\n};\n\n/**\n * Service function to retrieve multiple ").concat(t," based on query parameters.\n *\n * @param {object} query - The query parameters for filtering ").concat(t,".\n * @returns {Promise<Partial<I").concat(a,">[]>} - The retrieved ").concat(t,".\n */\nconst getMany").concat(a," = async (query: object): Promise<Partial<I").concat(a,">[]> => {\n  const ").concat(t," = await ").concat(a,"Model.find(query);\n  return ").concat(t,";\n};\n\nexport const ").concat(t,"Services = {\n  create").concat(a,",\n  createMany").concat(a,",\n  update").concat(a,",\n  updateMany").concat(a,",\n  delete").concat(a,",\n  deleteMany").concat(a,",\n  get").concat(a,"ById,\n  getMany").concat(a,",\n};\n    "),w=path.join(d,"".concat(args[0],".service.ts"));fs.writeFileSync(w,T.trim()),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(l(h)," ").concat(BLUE,"(").concat(Buffer.byteLength(m,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(l(v)," ").concat(BLUE,"(").concat(Buffer.byteLength(y,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(l(p)," ").concat(BLUE,"(").concat(Buffer.byteLength(u,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(l(g)," ").concat(BLUE,"(").concat(Buffer.byteLength(f,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(l(w)," ").concat(BLUE,"(").concat(Buffer.byteLength(T,"utf8")," bytes)")),console.log("".concat(GREEN,"CREATE ").concat(RESET).concat(l(I)," ").concat(BLUE,"(").concat(Buffer.byteLength($,"utf8")," bytes)"))}),program.parse(process.argv)):(console.error("Unknown command: ".concat(command)),process.exit(1));